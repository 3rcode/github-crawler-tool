Index,Message,Description,Message Abstract,Description Abstract
1,Handle clicks inside iframes (#2485),  Handle clicks inside iframes   Update changelog ,Handle clicks inside iframes (#2485),Handle clicks inside iframes Update changelog
2,Improve control over Menu and Listbox options while searching (#2471),"  add get-text-value helper   use getTextValue in Listbox component   use getTextValue in Menu component   update changelog   ensure we handle multiple values for aria-labelledby   hoist regex   drop child nodes instead of replacing its innerText   This makes it a bit slower but also more correct. We can use a cache on another level to ensure that we are not creating useless work.  add useTextValue to improve performance of getTextValue  This will add a cache and only if the innerText changes, only then will we calculate the new text value.  use better useTextValue hook",Improve control over Menu and Listbox options while searching (#2471),"add get-text-value helper use getTextValue in Listbox component use getTextValue in Menu component update changelog ensure we handle multiple values for aria-labelledby hoist regex drop child nodes instead of replacing its innerText This makes it a bit slower but also more correct. We can use a cache on another level to ensure that we are not creating useless work. add useTextValue to improve performance of getTextValue This will add a cache and only if the innerText changes, only then will we calculate the new text value. use better useTextValue hook"
3,Move types condition to the front (#2469),  move types condition to the front   Update changelog    Co-authored-by: Jordan Pittman jordan@cryptica.me,Move types condition to the front (#2469),move types condition to the front Update changelog Co-authored-by: Jordan Pittman jordan@cryptica.me
4,Stop <Transition appear> from overwriting classes on re-render (#2457), Add raw layout support to Vue playground  We can’t use ?raw here because Vite uses that itself for stuff. So here we opt for ?layout=raw instead   Fix Transition for appear overwriting classes on re-render   Set initial state just before animating   Remove unused import   Refactor   Capture snapshot of element just after first render   With the new setInitial call before the animation starts — we don’t see the actual initial render result in this test because the queue has been emptied by the time it ends  Update changelog,Stop  from overwriting classes on re-render (#2457),Add raw layout support to Vue playground We can’t use ?raw here because Vite uses that itself for stuff. So here we opt for ?layout=raw instead Fix Transition for appear overwriting classes on re-render Set initial state just before animating Remove unused import Refactor Capture snapshot of element just after first render With the new setInitial call before the animation starts — we don’t see the actual initial render result in this test because the queue has been emptied by the time it ends Update changelog
5,Ensure the exposed activeIndex is up to date for the Combobox component (#2463),  ensure the exposed activeIndex is up to date   update changelog ,Ensure the exposed activeIndex is up to date for the Combobox component (#2463),ensure the exposed activeIndex is up to date update changelog
6,refactor Portal to use useOnUnmount hook (#2458),,refactor Portal to use useOnUnmount hook (#2458),
7,ensure cb in useOnUnmount is a stable reference,,ensure cb in useOnUnmount is a stable reference,
8,Ensure FocusTrap is only active when the given enabled value is true (#2456),  fix(tabs): wrong tab focus when Tab contains a Dialog   refactor(focus-trap): rename variable and move logic   test(tabs): improve test by asserting the active element   ensure FocusTrap is not active when enabled = false   fix: move the enabled check to unmounting   refactor to useOnUnmount hook   This will allow us to make the code relatively similar between React and Vue.  update changelog   Co-authored-by: Robin Malfait malfait.robin@gmail.com,Ensure FocusTrap is only active when the given enabled value is true (#2456),fix(tabs): wrong tab focus when Tab contains a Dialog refactor(focus-trap): rename variable and move logic test(tabs): improve test by asserting the active element ensure FocusTrap is not active when enabled = false fix: move the enabled check to unmounting refactor to useOnUnmount hook This will allow us to make the code relatively similar between React and Vue. update changelog Co-authored-by: Robin Malfait malfait.robin@gmail.com
9,cleanup .gitignore,Co-authored-by: Noel De Martin noeldemartin@hey.com,cleanup .gitignore,Co-authored-by: Noel De Martin noeldemartin@hey.com
10,[internal] add demo mode to Menu and Popover components (#2448),  add demo mode to Menu and Popover   update changelog ,[internal] add demo mode to Menu and Popover components (#2448),add demo mode to Menu and Popover update changelog
11,Correctly handle IME composition in <Combobox.Input> (#2426),  Don’t try to open combobox when composing characters   wip   Delay IME composition end until after keydown events   Use d.nextFrame to handle compositionend event   Update changelog ,Correctly handle IME composition in  (#2426),Don’t try to open combobox when composing characters wip Delay IME composition end until after keydown events Use d.nextFrame to handle compositionend event Update changelog
12,Fix memory leak in Popover component (#2430),  move useTabDirection and handleFocus to setup instead of render function   update changelog ,Fix memory leak in Popover component (#2430),move useTabDirection and handleFocus to setup instead of render function update changelog
13,1.7.13 - @headlessui/vue,,1.7.13 - @headlessui/vue,
14,0.1.3 - @headlessui/tailwindcss,,0.1.3 - @headlessui/tailwindcss,
15,1.7.14 - @headlessui/react,,1.7.14 - @headlessui/react,
16,update changelog,,update changelog,
17,update changelog,,update changelog,
18,Ensure DOM ref is properly handled in the RadioGroup component (#2424)," drop by prop  Otherwise it ends up in the DOM which doesn't hurt but isn't ideal either.  ensure we are reading the underlying DOM correctly  We assumed that the optionRef was HTMLElement | null, but if you use a custom component, then it is exposed as { $el: ref }, this is why we use the dom() helper.   add test to ensure using a custom as prop works as expected   update changelog ",Ensure DOM ref is properly handled in the RadioGroup component (#2424),"drop by prop Otherwise it ends up in the DOM which doesn't hurt but isn't ideal either. ensure we are reading the underlying DOM correctly We assumed that the optionRef was HTMLElement | null, but if you use a custom component, then it is exposed as { $el: ref }, this is why we use the dom() helper. add test to ensure using a custom as prop works as expected update changelog"
19,Don't scroll lock when transition isn't showing (#2422),  Add tests   Make transition initial state based on computed show prop   Update changelog ,Don't scroll lock when transition isn't showing (#2422),Add tests Make transition initial state based on computed show prop Update changelog
20,Merge className correctly when it’s a function (#2412), Add className tests for render  Fix snapshots   Merge className correctly when it’s a function   Update changelog ,Merge className correctly when it’s a function (#2412),Add className tests for render Fix snapshots Merge className correctly when it’s a function Update changelog
21,Improve Combobox types to improve false positives (#2411)," swap Combobox type order  If you use the default Combobox component then it defaults to Fragment. This also means that if you provide an additional prop that it would be forwarded to the Fragment but that won't work. You do get a runtime error, but the types aren't 100% clear on what's going on. In fact, they make it very confusing because it will use the last ""fallback"" in all the Combobox definitions which marks the value as ""multiple"". Concretely, this means: ```ts let [value, setValue] = useState('Tom Cook')  ``` Starts complaining about the value and onChange not handling the multiple case correctly. But it should complain about the placeholder. Switching the order does solve this, but it is not the cleanest solution. Maybe we should be explicit about the Fragment case somehow. However, there is a use case where I don't think TypeScript will be able to help and it's a bit unfortunate. ```ts let [value, setValue] = useState('Tom Cook')          {/* ... */}      ``` This is valid because at runtime we will forward all the props to the div. So not 100% sure what we should do here instead.  update changelog",Improve Combobox types to improve false positives (#2411),"swap Combobox type order If you use the default Combobox component then it defaults to Fragment. This also means that if you provide an additional prop that it would be forwarded to the Fragment but that won't work. You do get a runtime error, but the types aren't 100% clear on what's going on. In fact, they make it very confusing because it will use the last ""fallback"" in all the Combobox definitions which marks the value as ""multiple"". Concretely, this means: ```ts let [value, setValue] = useState('Tom Cook') modulets let [value, setValue] = useState('Tom Cook') module ``` This is valid because at runtime we will forward all the props to the div. So not 100% sure what we should do here instead. update changelog"
22,Fix className hydration for <Transition appear> (#2390),  Fix className hydration for <Transition appear>   Update changelog ,Fix className hydration for  (#2390),Fix className hydration for  Update changelog
23,Add ESM and types paths to package.json for TailwindCSS plugin (#2382),  Add ESM and types paths to package.json for TailwindCSS plugin   Move types declaration to first key in exports ,Add ESM and types paths to package.json for TailwindCSS plugin (#2382),Add ESM and types paths to package.json for TailwindCSS plugin Move types declaration to first key in exports
24,Add FocusTrap event listeners once document has loaded (#2389),  feat: addEventListener on document loaded   Refactor   Fix import   Update changelog   use function instead of arrow function   make callback in onDocumentReady mandatory    Co-authored-by: lkr lkr@bytedance.com Co-authored-by: Jordan Pittman jordan@cryptica.me Co-authored-by: Robin Malfait malfait.robin@gmail.com,Add FocusTrap event listeners once document has loaded (#2389),feat: addEventListener on document loaded Refactor Fix import Update changelog use function instead of arrow function make callback in onDocumentReady mandatory Co-authored-by: lkr lkr@bytedance.com Co-authored-by: Jordan Pittman jordan@cryptica.me Co-authored-by: Robin Malfait malfait.robin@gmail.com
25,[vue] Fix Combobox input disabled state (#2375),  [vue] Fix Combobox input disabled state   Add tests for disabled input in React and Vue   Update changelog    Co-authored-by: Jordan Pittman jordan@cryptica.me,[vue] Fix Combobox input disabled state (#2375),[vue] Fix Combobox input disabled state Add tests for disabled input in React and Vue Update changelog Co-authored-by: Jordan Pittman jordan@cryptica.me
26,"Fix ""Can't perform a React state update on an unmounted component."" when using the Transition component (#2374)",  only change flags when mounted   update changelog ,"Fix ""Can't perform a React state update on an unmounted component."" when using the Transition component (#2374)",only change flags when mounted update changelog
27,"Add form prop to form-like components such as RadioGroup, Switch, Listbox, and Combobox (#2356)",  Adds form prop to Switch component   add form prop to Switch component in Vue   tests for both React and Vue   add form prop to Combobox component   add form prop to Listbox comopnent   add form prop to RadioGroup component   update changelog   add Oxford comma   cleanup screen import    Co-authored-by: Robin Malfait malfait.robin@gmail.com,"Add form prop to form-like components such as RadioGroup, Switch, Listbox, and Combobox (#2356)",Adds form prop to Switch component add form prop to Switch component in Vue tests for both React and Vue add form prop to Combobox component add form prop to Listbox comopnent add form prop to RadioGroup component update changelog add Oxford comma cleanup screen import Co-authored-by: Robin Malfait malfait.robin@gmail.com
28,Fix focus styles showing up when using the mouse (#2347),"  update playground examples to use a shared Button   expose a ui-focus-visible variant   keep track of a data-headlessui-focus-visible attribute   do not set the tabindex   The focus was always set, but the ring wasn't showing up. This was also focusing a ring when the browser decided not the add one. Let's make the browser decide when to show this or not.  update changelog",Fix focus styles showing up when using the mouse (#2347),"update playground examples to use a shared Button expose a ui-focus-visible variant keep track of a data-headlessui-focus-visible attribute do not set the tabindex The focus was always set, but the ring wasn't showing up. This was also focusing a ring when the browser decided not the add one. Let's make the browser decide when to show this or not. update changelog"
29,1.7.12 - @headlessui/vue,,1.7.12 - @headlessui/vue,
30,1.7.13 - @headlessui/react,,1.7.13 - @headlessui/react,
31,Ensure hooks in the FocusTrap component only apply when mounted (#2331),  ensure hooks in the FocusTrap component only apply when mounted   update changelog ,Ensure hooks in the FocusTrap component only apply when mounted (#2331),ensure hooks in the FocusTrap component only apply when mounted update changelog
32,"Fix restore focus to buttons in Safari, when Dialog component closes (#2326)"," update dialog playground example  Includes a generic Button component that has explicit focus styles.  keep track of ""focus"" history  Safari doesn't ""focus"" buttons when you mousedown on them. This means that we don't capture the correct element to restore focus to when closing a Dialog for example. Now, we will make sure to keep track of a list of last ""focused"" items. We do this by also capturing elements when you ""click"", ""mousedown"" or ""focus"".   let's use a button instead of a div in tests   make target for Vue consistent with React   update changelog ","Fix restore focus to buttons in Safari, when Dialog component closes (#2326)","update dialog playground example Includes a generic Button component that has explicit focus styles. keep track of ""focus"" history Safari doesn't ""focus"" buttons when you mousedown on them. This means that we don't capture the correct element to restore focus to when closing a Dialog for example. Now, we will make sure to keep track of a list of last ""focused"" items. We do this by also capturing elements when you ""click"", ""mousedown"" or ""focus"". let's use a button instead of a div in tests make target for Vue consistent with React update changelog"
33,retry tests 3 times before failing (#2335),"Some tests are relying on timing specific tests and if the server (GitHub Actions) is a bit busy, then this can result in flakey tests. One day we will switch to tests in a real browser, but in the meantime this should be enough.",retry tests 3 times before failing (#2335),"Some tests are relying on timing specific tests and if the server (GitHub Actions) is a bit busy, then this can result in flakey tests. One day we will switch to tests in a real browser, but in the meantime this should be enough."
34,Fix invalid warning when using multiple Popover.Button components inside a Popover.Panel (#2333),  add a bunch of tests to ensure we won't regress on this again   fix incorrect warning when using multiple Popover.Button inside Popover.Panel   update changelog ,Fix invalid warning when using multiple Popover.Button components inside a Popover.Panel (#2333),add a bunch of tests to ensure we won't regress on this again fix incorrect warning when using multiple Popover.Button inside Popover.Panel update changelog
35,Fix XYZPropsWeControl and cleanup internal TypeScript types (#2329)," cleanup XYZPropsWeControl  The idea behind the PropsWeControl is that we can omit all the fields that we are controlling entirely. In this case, passing a prop like role, but if we already set the role ourselves then the prop won't do anything at all. This is why we want to alert the end user that it is an ""error"". It can also happen that we ""control"" the value by default, but keep incoming props into account. For example we generate a unique ID for most components, but you can provide your own to override it. In this case we don't want to include the ID in the XYZPropsWeControl. Additionally, we introduced some functionality months ago where we call event callbacks (onClick, ...) from the incoming props before our own callbacks. This means that by definition all onXYZ callbacks can be provided.  improve defining types  Whenever we explicitly provide custom types for certain props, then we make sure to omit those keys first from the original props (of let's say an input). This is important so that TypeScript doesn't try to ""merge"" those types together.   cleanup: move useEffect   add defaultValue explicitly   ensure tests are not using any because of onChange={console.log}   The console.log is typed as (...args: any[]) => void which means that it will incorrectly mark its incoming data as any as well. Converting it to x => console.log(x) makes TypeScript happy. Or in this case, angry since it found a bug. This is required because it can be that your value (e.g.: the value of a Combobox) is an object (e.g.: a User), but it is also nullable. Therefore we can provide the value null. This would mean that eventually this resolves to keyof null which is never, but we just want a string in this case. diff -export type ByComparator<T> = (keyof T & string) | ((a: T, b: T) => boolean) +export type ByComparator<T> = +  | (T extends null ? string : keyof T & string) +  | ((a: T, b: T) => boolean)   improve the internal types of the Combobox component   improve the internal types of the Disclosure component   improve the internal types of the Listbox component   improve the internal types of the Menu component   improve the internal types of the Popover component   improve the internal types of the Tabs component   improve the internal types of the Transition component   use Override in Hidden as well   cleanup unused code   don't check the useSyncExternalStoreShimClient   don't check the useSyncExternalStoreShimServer   improve types in the render tests   fix Ref<TTag> to be Ref<HTMLElement>   improve internal types of the Transition component (Vue)   add attrs.class as well   use different type for AnyComponent   update changelog ",Fix XYZPropsWeControl and cleanup internal TypeScript types (#2329),"cleanup XYZPropsWeControl The idea behind the PropsWeControl is that we can omit all the fields that we are controlling entirely. In this case, passing a prop like role, but if we already set the role ourselves then the prop won't do anything at all. This is why we want to alert the end user that it is an ""error"". It can also happen that we ""control"" the value by default, but keep incoming props into account. For example we generate a unique ID for most components, but you can provide your own to override it. In this case we don't want to include the ID in the XYZPropsWeControl. Additionally, we introduced some functionality months ago where we call event callbacks (onClick, ...) from the incoming props before our own callbacks. This means that by definition all onXYZ callbacks can be provided. improve defining types Whenever we explicitly provide custom types for certain props, then we make sure to omit those keys first from the original props (of let's say an input). This is important so that TypeScript doesn't try to ""merge"" those types together. cleanup: move useEffect add defaultValue explicitly ensure tests are not using any because of onChange={console.log} The console.log is typed as (...args: any[]) => void which means that it will incorrectly mark its incoming data as any as well. Converting it to x => console.log(x) makes TypeScript happy. Or in this case, angry since it found a bug. This is required because it can be that your value (e.g.: the value of a Combobox) is an object (e.g.: a User), but it is also nullable. Therefore we can provide the value null. This would mean that eventually this resolves to keyof null which is never, but we just want a string in this case. diff -export type ByComparator = (keyof T & string) | ((a: T, b: T) => boolean) +export type ByComparator = +  | (T extends null ? string : keyof T & string) +  | ((a: T, b: T) => boolean) improve the internal types of the Combobox component improve the internal types of the Disclosure component improve the internal types of the Listbox component improve the internal types of the Menu component improve the internal types of the Popover component improve the internal types of the Tabs component improve the internal types of the Transition component use Override in Hidden as well cleanup unused code don't check the useSyncExternalStoreShimClient don't check the useSyncExternalStoreShimServer improve types in the render tests fix Ref to be Ref improve internal types of the Transition component (Vue) add attrs.class as well use different type for AnyComponent update changelog"
36,Allow root containers from the Dialog component in the FocusTrap component (#2322),  add (failing) test to verify moving focus to 3rd party containers work   pass resolveRootContainers to FocusTrap   handle lazy containers in FocusTrap   update changelog ,Allow root containers from the Dialog component in the FocusTrap component (#2322),add (failing) test to verify moving focus to 3rd party containers work pass resolveRootContainers to FocusTrap handle lazy containers in FocusTrap update changelog
37,Enable native label behavior for Switch component (#2265),  add native label behavior for switch   Add reference tests for React and Vue   These don’t work in JSDOM so they’re skipped but we can use these to reference expected behavior once we have playwright-based tests   Fix Vue playground switch example   Only prevent default when the element is a label   Port change to Vue   Update changelog    Co-authored-by: Jordan Pittman jordan@cryptica.me,Enable native label behavior for Switch component (#2265),add native label behavior for switch Add reference tests for React and Vue These don’t work in JSDOM so they’re skipped but we can use these to reference expected behavior once we have playwright-based tests Fix Vue playground switch example Only prevent default when the element is a label Port change to Vue Update changelog Co-authored-by: Jordan Pittman jordan@cryptica.me
38,Ensure Transition component completes if nothing is transitioning (#2318)," make disposables consistent  Also added a group function, this allows us to spawn a sub disposables group that can be disposed on its own, but will also be disposed the moment the ""parent"" is disposed.   ensure Transition component works when nothing is transitioning   update changelog ",Ensure Transition component completes if nothing is transitioning (#2318),"make disposables consistent Also added a group function, this allows us to spawn a sub disposables group that can be disposed on its own, but will also be disposed the moment the ""parent"" is disposed. ensure Transition component works when nothing is transitioning update changelog"
39,1.7.11 - @headlessui/vue,,1.7.11 - @headlessui/vue,
40,1.7.12 - @headlessui/react,,1.7.12 - @headlessui/react,
41,Fix Dialog cleanup when the Dialog becomes hidden (#2303)," use the Dialog's parent as the root for the Intersection observer  We have some code that allows us to auto-close the dialog the moment it gets hidden. This is useful if you use a dialog for a mobile menu and you resizet he browser. If you wrap the dialog in a md:hidden then it auto closes. If we don't do this, then the dialog is still locking the scrolling, keeping the focus in the dialog, ... but it is not visible. To solve this we use an IntersectionObserver to verify that the boundingClientRect is ""gone"" (x = 0, y = 0, width = 0 and height = 0). However, the intersection observer is not always triggered. This happens if the main content is scrollable. Setting the root of the IntersectionObserver to the parent of the Dialog does seem to solve it. Not 100% sure what causes this behaviour exactly.   use a ResizeObserver instead of IntersectionObserver   implement a ResizeObserver for the tests   update changelog ",Fix Dialog cleanup when the Dialog becomes hidden (#2303),"use the Dialog's parent as the root for the Intersection observer We have some code that allows us to auto-close the dialog the moment it gets hidden. This is useful if you use a dialog for a mobile menu and you resizet he browser. If you wrap the dialog in a md:hidden then it auto closes. If we don't do this, then the dialog is still locking the scrolling, keeping the focus in the dialog, ... but it is not visible. To solve this we use an IntersectionObserver to verify that the boundingClientRect is ""gone"" (x = 0, y = 0, width = 0 and height = 0). However, the intersection observer is not always triggered. This happens if the main content is scrollable. Setting the root of the IntersectionObserver to the parent of the Dialog does seem to solve it. Not 100% sure what causes this behaviour exactly. use a ResizeObserver instead of IntersectionObserver implement a ResizeObserver for the tests update changelog"
42,fix false positive log when running tests,Let's wrap the test in act to get rid of the warning. In practice (while testing in the browser) the actual warning doesn't seem to affect the user experience at all. The act function is typed in a strange way (Promise<undefined> & void). Yet the actual contents of the act callback is returned as expected. Therefore we overrode the type of act to make sure this reflects reality better. (Thanks @thecrypticace!) Also added an additional check to make sure the actual container is available to extra ensure we are not lying by overriding the type.,fix false positive log when running tests,Let's wrap the test in act to get rid of the warning. In practice (while testing in the browser) the actual warning doesn't seem to affect the user experience at all. The act function is typed in a strange way (Promise & void). Yet the actual contents of the act callback is returned as expected. Therefore we overrode the type of act to make sure this reflects reality better. (Thanks @thecrypticace!) Also added an additional check to make sure the actual container is available to extra ensure we are not lying by overriding the type.
43,Fix change event incorrectly getting called on blur (#2296)," drop d.enqueue & d.workQueue  This was only used in tests and doesn't seem to be necessary.  drop handleChange from the ComboboxInput component  This only emitted a change event, which Vue already emits as well.  drop onChange from incoming props  This is an odd one. In Chrome this means that the @change is still being called, but if we keep it, then the @change is also called on blur resulting in odd bugs. Droping it fixes that issue. That said, the @change is still emitted and therefore the callback is properly called and the ComboboxInput still can interact with the @change event.  update changelog",Fix change event incorrectly getting called on blur (#2296),"drop d.enqueue & d.workQueue This was only used in tests and doesn't seem to be necessary. drop handleChange from the ComboboxInput component This only emitted a change event, which Vue already emits as well. drop onChange from incoming props This is an odd one. In Chrome this means that the @change is still being called, but if we keep it, then the @change is also called on blur resulting in odd bugs. Droping it fixes that issue. That said, the @change is still emitted and therefore the callback is properly called and the ComboboxInput still can interact with the @change event. update changelog"
44,Make React types more compatible with other libraries (#2282),  Export explicit props types   wip   wip   wip   wip dialog types   wip   Fix build   Upgrade esbuild   Add aliased types for ComponentLabel and ComponentDescription   Update lockfile   Update changelog   Update exported prop type names   Make onChange optional   Update tests   Use never in CleanProps   Using a branded type doesn’t work properly with unions   Fix types   wip   work on types   wip   wip   Tweak types in render helpers   Fix CS   Fix changelog   Tweak render prop types for combobox   Update hidden props type name   remove unused type   Tweak types   Update TypeScript version ,Make React types more compatible with other libraries (#2282),Export explicit props types wip wip wip wip dialog types wip Fix build Upgrade esbuild Add aliased types for ComponentLabel and ComponentDescription Update lockfile Update changelog Update exported prop type names Make onChange optional Update tests Use never in CleanProps Using a branded type doesn’t work properly with unions Fix types wip work on types wip wip Tweak types in render helpers Fix CS Fix changelog Tweak render prop types for combobox Update hidden props type name remove unused type Tweak types Update TypeScript version
45,Fix nested Popover components not opening (#2293),  fix nested Popovers not working   update changelog ,Fix nested Popover components not opening (#2293),fix nested Popovers not working update changelog
46,Ensure the main tree and parent Dialog components are marked as inert (#2290),"  drop @ts-expect-error, because inert is available now   fix logical error   We want to apply inert when we don't have nested dialogs, because if we do have nested dialogs, then the inert should be applied from the nested dialog (or visually the top most dialog).   update changelog   replace useInertOthers with useInert   add assertInert and assertNotInert accessibility assertion helpers   ensure the main tree root is marked as inert   As well as the parent dialogs in case of nested dialogs.",Ensure the main tree and parent Dialog components are marked as inert (#2290),"drop @ts-expect-error, because inert is available now fix logical error We want to apply inert when we don't have nested dialogs, because if we do have nested dialogs, then the inert should be applied from the nested dialog (or visually the top most dialog). update changelog replace useInertOthers with useInert add assertInert and assertNotInert accessibility assertion helpers ensure the main tree root is marked as inert As well as the parent dialogs in case of nested dialogs."
47,update CHANGELOG,,update CHANGELOG,
48,1.7.10 - @headlessui/vue,,1.7.10 - @headlessui/vue,
49,1.7.11 - @headlessui/react,,1.7.11 - @headlessui/react,
50,change test to test whether the underlying dom tag is changed to span when using as prop (#2283),Test in line 105 already covers using the as tag to change the underlying dom tag to an anchor tag. Therefore we can test whether a span tag is correctly rendered for example.,change test to test whether the underlying dom tag is changed to span when using as prop (#2283),Test in line 105 already covers using the as tag to change the underlying dom tag to an anchor tag. Therefore we can test whether a span tag is correctly rendered for example.
51,Start cleanup phase of the Dialog component when going into the Closing state (#2264)," introduce opening and closing states  Also represent them as bits so that we can easily combine them while we are transitioning from one state to the other.  update open/closed state checks  Instead of checking whether it is in one state or an other, we can check if the current state contains some potential sub-state. This allows us to still check if we are in the Open state, while also Closing because the state will be S.Open | S.Closing.   expose flags from the useFlags hook   add the Closing and Opening states to the Open/Closed state   create dedicated abcEnabled variables   keep the State.Closing into account for scroll locking and inert others   add a test for the Closing state impacting the Dialog component   cleanup unused imports   add unmount util to the Vue Test renderer   update changelog ",Start cleanup phase of the Dialog component when going into the Closing state (#2264),"introduce opening and closing states Also represent them as bits so that we can easily combine them while we are transitioning from one state to the other. update open/closed state checks Instead of checking whether it is in one state or an other, we can check if the current state contains some potential sub-state. This allows us to still check if we are in the Open state, while also Closing because the state will be S.Open | S.Closing. expose flags from the useFlags hook add the Closing and Opening states to the Open/Closed state create dedicated abcEnabled variables keep the State.Closing into account for scroll locking and inert others add a test for the Closing state impacting the Dialog component cleanup unused imports add unmount util to the Vue Test renderer update changelog"
52,update changelog,,update changelog,
53,refactor: use proper type for switch forward ref (#2277),,refactor: use proper type for switch forward ref (#2277),
54,Ensure we reset the activeOptionIndex if the active option is unmounted (#2274)," ensure we reset the activeOptionIndex if the active option is unmounted  Unmounting of the active option can happen when you are in a multi-select Combobox, and you filter out all the selected values. This means that the moment you press ""Enter"" on an active item, it becomes the selected item and therefore will be filtered out.  update changelog",Ensure we reset the activeOptionIndex if the active option is unmounted (#2274),"ensure we reset the activeOptionIndex if the active option is unmounted Unmounting of the active option can happen when you are in a multi-select Combobox, and you filter out all the selected values. This means that the moment you press ""Enter"" on an active item, it becomes the selected item and therefore will be filtered out. update changelog"
55,Re-focus Combobox.Input when a Combobox.Option is selected (#2272)," re-focus Combobox.Input when a Combobox.Option is selected  Except on mobile devices (ideally devices using a virtual keyboard), so that the virtual keyboard won't be triggered every single time we re-focus that input field.  update changelog",Re-focus Combobox.Input when a Combobox.Option is selected (#2272),"re-focus Combobox.Input when a Combobox.Option is selected Except on mobile devices (ideally devices using a virtual keyboard), so that the virtual keyboard won't be triggered every single time we re-focus that input field. update changelog"
56,Move aria-multiselectable to [role=listbox] in the Combobox component (#2271),  move aria-multiselectable to [role=listbox] in the Combobox component   update changelog ,Move aria-multiselectable to [role=listbox] in the Combobox component (#2271),move aria-multiselectable to [role=listbox] in the Combobox component update changelog
57,Don’t fire afterLeave event more than once for a given transition (#2267),  Don’t fire afterLeave event more than once for a given component   Port test to React   Fix CS   Remove focus on test   Update changelog ,Don’t fire afterLeave event more than once for a given transition (#2267),Don’t fire afterLeave event more than once for a given component Port test to React Fix CS Remove focus on test Update changelog
58,Ensure we handle null dataRef values correctly (#2258)," ensure we handle null dataRef values correctly  Initially when the dataRef is created, then the current value is going to be null. We didn't properly encode this in the types. Now that we do, it exposed some places where this was used incorrectly (because we assumed it was always defined).  update changelog",Ensure we handle null dataRef values correctly (#2258),"ensure we handle null dataRef values correctly Initially when the dataRef is created, then the current value is going to be null. We didn't properly encode this in the types. Now that we do, it exposed some places where this was used incorrectly (because we assumed it was always defined). update changelog"
59,cleanup CHANGELOG,,cleanup CHANGELOG,
60,1.7.10 - @headlessui/react,,1.7.10 - @headlessui/react,
61,update CHANGELOG,,update CHANGELOG,
62,"Revert ""Use the import * as React from 'react' pattern (#2242)""",This reverts commit 0276231c318f443f1821de29e7cb08b0c9b5f003.,"Revert ""Use the import * as React from 'react' pattern (#2242)""",This reverts commit 0276231c318f443f1821de29e7cb08b0c9b5f003.
63,1.7.9 - @headlessui/vue,,1.7.9 - @headlessui/vue,
64,1.7.9 - @headlessui/react,,1.7.9 - @headlessui/react,
65,Preserve default index when starting out with no tabs (#2250),  Preserve default index when starting out with no tabs   Add test to Vue   Add test for Vue   it already works here so… yeah,Preserve default index when starting out with no tabs (#2250),Preserve default index when starting out with no tabs Add test to Vue Add test for Vue it already works here so… yeah
66,Use the import * as React from 'react' pattern (#2242)," use the import * as React from 'react' pattern  We use named imports, but we have to import React itself as well for JSX because it compiles to React.createElement. We could get rid of our own JSX and use it directly, or we can use this import * as React from 'react' syntax. This fixes an issue for people using allowSyntheticDefaultImports: false in TypeScript. Fixes: #2117  update changelog",Use the import * as React from 'react' pattern (#2242),"use the import * as React from 'react' pattern We use named imports, but we have to import React itself as well for JSX because it compiles to React.createElement. We could get rid of our own JSX and use it directly, or we can use this import * as React from 'react' syntax. This fixes an issue for people using allowSyntheticDefaultImports: false in TypeScript. Fixes: #2117 update changelog"
67,"Fix ""This Suspense boundary received an update before it finished hydrating"" error in the Disclosure component (#2238)",  use startTransition to work around Suspense boundary crash   update changelog ,"Fix ""This Suspense boundary received an update before it finished hydrating"" error in the Disclosure component (#2238)",use startTransition to work around Suspense boundary crash update changelog
68,Don't break overflow when multiple dialogs are open at the same time (#2215),  Fix overflow when swapping dialogs that use transition   Refactor   refactor   wip   wip   wip   wip   wip   wip   wip   wip   Inline shim for ESM support   Until the official package adds an ESM version with a wildcard import we can’t use it. This version was copied from Remix Router   Add dialog shadow root examples   Fix SSR error   Add repro for iOS scrolling issue   Try to fix vercel build   idk what’s wrong here  Update repro  A transition is required to delay closing enough to demonstrate the bug   Port global dialog state to Vue   Add dialog test to Vue   wip   wip   Workaround bug   This shouldn’t happen at all and we need to find the source of the bug but this should “fix” things for the time being   wip   Rebuild overflow locking with simpler API   wip   wip   wip   wip   wip   wip   wip   wip   wip   Update deps   wip   simplify   Port to Vue   wip   wip   Tweak tests   Update changelog   Ensure meta callbacks are cleaned up   cleanup   wip ,Don't break overflow when multiple dialogs are open at the same time (#2215),Fix overflow when swapping dialogs that use transition Refactor refactor wip wip wip wip wip wip wip wip Inline shim for ESM support Until the official package adds an ESM version with a wildcard import we can’t use it. This version was copied from Remix Router Add dialog shadow root examples Fix SSR error Add repro for iOS scrolling issue Try to fix vercel build idk what’s wrong here Update repro A transition is required to delay closing enough to demonstrate the bug Port global dialog state to Vue Add dialog test to Vue wip wip Workaround bug This shouldn’t happen at all and we need to find the source of the bug but this should “fix” things for the time being wip Rebuild overflow locking with simpler API wip wip wip wip wip wip wip wip wip Update deps wip simplify Port to Vue wip wip Tweak tests Update changelog Ensure meta callbacks are cleaned up cleanup wip
69,Fix SSR tab hydration when using Strict Mode in development (#2231),  Work on SSR tests for react   Use React internals to count tabs and panels   React’s double rendering in strict mode in development makes SSR + hydration matching impossible without reaching into internals. This is unfortunate but the way react works. Production builds of React are unaffected by this but still require a consistent mechanism that works so in that case we use Symbols just like we do in SSR.  Update changelog,Fix SSR tab hydration when using Strict Mode in development (#2231),Work on SSR tests for react Use React internals to count tabs and panels React’s double rendering in strict mode in development makes SSR + hydration matching impossible without reaching into internals. This is unfortunate but the way react works. Production builds of React are unaffected by this but still require a consistent mechanism that works so in that case we use Symbols just like we do in SSR. Update changelog
70,fix(@headless-react / @headless-vue): update WAI-ARIA reference links (#2230),  fix(@headlessui/react): WAI-ARIA reference links   fix(@headlessui-vue): Fix WAI-ARIA reference links    Co-authored-by: lumilno nooa.lumilaakso@gmail.com,fix(@headless-react / @headless-vue): update WAI-ARIA reference links (#2230),fix(@headlessui/react): WAI-ARIA reference links fix(@headlessui-vue): Fix WAI-ARIA reference links Co-authored-by: lumilno nooa.lumilaakso@gmail.com
71,1.7.8 - @headlessui/vue,,1.7.8 - @headlessui/vue,
72,1.7.8 - @headlessui/react,,1.7.8 - @headlessui/react,
73,Fix shadow-root bug closing Dialog containers (#2217),  ensure we consider html > * as valid containers as well   update changelog ,Fix shadow-root bug closing Dialog containers (#2217),ensure we consider html > * as valid containers as well update changelog
74,Allow setting tabIndex on the Tab.Panel (#2214),  allow setting tabIndex on the Tab.Panel   update changelog ,Allow setting tabIndex on the Tab.Panel (#2214),allow setting tabIndex on the Tab.Panel update changelog
75,Improve Tabs wrapping around when controlling the component and overflowing the selectedIndex (#2213)," ensure chaning the selectedIndex tabs properly wraps around  We never want to use and index that doesn't map to a proper tab. This commit also makes the implementation similar for both React and Vue.   add tests to prove the underflow and overflow wrapping   drop updating the index manually   This is already adjusted when tabs change internally. You can still manually change it of course, but for these tests that doesn't matter and cause different results.  update changelog",Improve Tabs wrapping around when controlling the component and overflowing the selectedIndex (#2213),"ensure chaning the selectedIndex tabs properly wraps around We never want to use and index that doesn't map to a proper tab. This commit also makes the implementation similar for both React and Vue. add tests to prove the underflow and overflow wrapping drop updating the index manually This is already adjusted when tabs change internally. You can still manually change it of course, but for these tests that doesn't matter and cause different results. update changelog"
76,Fix FocusTrap in Dialog when there is only 1 focusable element (#2172),  add tests to guarantee FocusTrap with a single element works as expected   it should keep the focus in the Dialog   Even if there is only 1 element. We were skipping the current active element so the container didn't have any elements anymore and just continued to the next focusable element in line. This will prevent that and ensure that we can only skip elements if there are multiple ones.  update changelog,Fix FocusTrap in Dialog when there is only 1 focusable element (#2172),add tests to guarantee FocusTrap with a single element works as expected it should keep the focus in the Dialog Even if there is only 1 element. We were skipping the current active element so the container didn't have any elements anymore and just continued to the next focusable element in line. This will prevent that and ensure that we can only skip elements if there are multiple ones. update changelog
77,Fix crash when reading headlessuiFocusGuard of relatedTarget in the FocusTrap component (#2203)," ensure relatedTarget is an HTMLElement  Or in other words, Robin trust the type system... I was assuming that this was always an HTMLElement or null but that's not the case. Just using e.relatedTarget shows that dataset is not always available.  update changelog",Fix crash when reading headlessuiFocusGuard of relatedTarget in the FocusTrap component (#2203),"ensure relatedTarget is an HTMLElement Or in other words, Robin trust the type system... I was assuming that this was always an HTMLElement or null but that's not the case. Just using e.relatedTarget shows that dataset is not always available. update changelog"
78,Improve Combobox accessibility (#2153),  add the aria-autocomplete attribute   drop the aria-activedescendant attribute on the Combobox.Options component   It is only required on the Combobox.Input component.  improve triggering VoiceOver when opening the Combobox  We do this by mutating the input value for a split second to trigger a change that VoiceOver will pick up. We will also ensure to restore the value and the selection / cursor position so that the end user won't notice a difference at all.  update changelog  Fixes: #2129 Co-authored-by: Andrea Fercia a.fercia@gmail.com,Improve Combobox accessibility (#2153),add the aria-autocomplete attribute drop the aria-activedescendant attribute on the Combobox.Options component It is only required on the Combobox.Input component. improve triggering VoiceOver when opening the Combobox We do this by mutating the input value for a split second to trigger a change that VoiceOver will pick up. We will also ensure to restore the value and the selection / cursor position so that the end user won't notice a difference at all. update changelog Fixes: #2129 Co-authored-by: Andrea Fercia a.fercia@gmail.com
79,cleanup unused import (#2184),,cleanup unused import (#2184),
80,Don’t overwrite classes during SSR when rendering fragments (#2173),  Refactor SSR test helpers   Add SSR tests for transition   Don’t overwrite classes during SSR when rendering fragments   Update changelog ,Don’t overwrite classes during SSR when rendering fragments (#2173),Refactor SSR test helpers Add SSR tests for transition Don’t overwrite classes during SSR when rendering fragments Update changelog
81,Fix failed to removeChild on Node bug (#2164), fix failed to removeChild on Node bug  Let's introduce a bit more defensive code to make sure that the code doesn't crash when we don't pass a Node to removeChild  update changelog,Fix failed to removeChild on Node bug (#2164),fix failed to removeChild on Node bug Let's introduce a bit more defensive code to make sure that the code doesn't crash when we don't pass a Node to removeChild update changelog
82,Fix false positive warning when using <Popover.Button /> in React 17 (#2163),  fix false positive warning when using  in React 17   update changelog ,Fix false positive warning when using  in React 17 (#2163),fix false positive warning when using  in React 17 update changelog
83,Fix Tab key with non focusable elements in Popover.Panel (#2147), fix Tab key with non focusable elements in Popover.Panel  Fixes: #2112   ensure all Dialog tests are running   update changelog ,Fix Tab key with non focusable elements in Popover.Panel (#2147),fix Tab key with non focusable elements in Popover.Panel Fixes: #2112 ensure all Dialog tests are running update changelog
84,Fix false positive warning about using multiple <Popover.Button> components (#2146), fix false positive warning about using multiple <Popover.Button> components  Fixes: #2143  update changelog,Fix false positive warning about using multiple  components (#2146),fix false positive warning about using multiple  components Fixes: #2143 update changelog
85,Fix arrow key handling in Tab (after DOM order changes) (#2145)," detect change in Tab order  This will guarantee that when you are using your arrow keys that the previous / next values are the correct ones instead of the ""old"" values before the order change happened. Fixes: #2131  update changelog",Fix arrow key handling in Tab (after DOM order changes) (#2145),"detect change in Tab order This will guarantee that when you are using your arrow keys that the previous / next values are the correct ones instead of the ""old"" values before the order change happened. Fixes: #2131 update changelog"
86,"Ensure disabled=""false"" is not incorrectly passed to the underlying DOM Node (#2138)"," do not add disabled prop to MenuItem  We use the aria-disabled instead so that you can still style it and that assistive techonology can read the disabled state. If it has the disabled prop itself, then often you can't interact with it at all. We also default to disabled = false, which means that the default behaviour was a <element disabled=""false""> in the DOM. If you then have CSS like [disabled] { opacity: 0.8; } then this also applies to the elements with disabled=""false"". Fixes: #2134   ensure Vue playground still works   ensure Vue overrides the onXXX correctly   update changelog ","Ensure disabled=""false"" is not incorrectly passed to the underlying DOM Node (#2138)","do not add disabled prop to MenuItem We use the aria-disabled instead so that you can still style it and that assistive techonology can read the disabled state. If it has the disabled prop itself, then often you can't interact with it at all. We also default to disabled = false, which means that the default behaviour was a  in the DOM. If you then have CSS like [disabled] { opacity: 0.8; } then this also applies to the elements with disabled=""false"". Fixes: #2134 ensure Vue playground still works ensure Vue overrides the onXXX correctly update changelog"
87,Update README.md (#2135),,Update README.md (#2135),
88,Fix SSR tab rendering on React 17 (#2102),  Allow clicks inside dialog panel when target is inside shadow root   Introduce resettable “server” state   This will aid in testing   Add SSR and hydration tests for react   Fix server rendering of Tabs on React 17   Fix CS   Skip hydration tests   Tweak SSR implementation in Vue   Update changelog ,Fix SSR tab rendering on React 17 (#2102),Allow clicks inside dialog panel when target is inside shadow root Introduce resettable “server” state This will aid in testing Add SSR and hydration tests for react Fix server rendering of Tabs on React 17 Fix CS Skip hydration tests Tweak SSR implementation in Vue Update changelog
89,1.7.7 - @headlessui/vue,,1.7.7 - @headlessui/vue,
90,1.7.7 - @headlessui/react,,1.7.7 - @headlessui/react,
91,update changelog,,update changelog,
92,improve scrolling to in-page location,,improve scrolling to in-page location,
93,1.7.6 - @headlessui/vue,,1.7.6 - @headlessui/vue,
94,1.7.6 - @headlessui/react,,1.7.6 - @headlessui/react,
95,update CHANGELOG,,update CHANGELOG,
96,improve scroll offset,,improve scroll offset,
97,update aria-haspopup to use the correct role (#2101),"aria-haspopup should now contain the corresponding role instead of just true or false. The aria-haspopup=""true"" is considered a menu now. Context: https://w3c.github.io/aria/#aria-haspopup Fixes: #2099",update aria-haspopup to use the correct role (#2101),"aria-haspopup should now contain the corresponding role instead of just true or false. The aria-haspopup=""true"" is considered a menu now. Context: link Fixes: #2099"
98,Improve scroll locking on iOS (#2100),"  improve types for addEventListener inside disposables   improve scroll locking   Instead of using the ""simple"" hack with the position: fixed; we now went back to the touchmove implementation. The position: fixed; causes some annoying issues. For starters, on iOS you will now get a strange gap (due to safe areas). Some applications also saw ""blank"" screens based on how the page was implemented. We also saw some issues internally, where clicking changing the scroll position on the main page from within the Dialog. Think about something along the lines of: html <a href=""#interesting-link-on-the-current-page"">Interesting link on the page</a> This doesn't work becauase the page is now fixed, and there is nothing to scroll... Instead, we now use the touchmove again. The problem with this last time was that this disabled all touch move events. This is obviously not good. Luckily, we already have a concept of ""safe containers"". This is what we use for the outside click behaviour as well. Basically in a Dialog, your Dialog.Panel is the safe container. But also third party DOM elements that are rendered inside that Panel (or as a sibling of the Dialog, but not your main app). We can re-use this knowledge of ""safe containers"", and only cancel the touchmove behaviour if this didn't happen in any of the safe containers.  update changelog",Improve scroll locking on iOS (#2100),"improve types for addEventListener inside disposables improve scroll locking Instead of using the ""simple"" hack with the position: fixed; we now went back to the touchmove implementation. The position: fixed; causes some annoying issues. For starters, on iOS you will now get a strange gap (due to safe areas). Some applications also saw ""blank"" screens based on how the page was implemented. We also saw some issues internally, where clicking changing the scroll position on the main page from within the Dialog. Think about something along the lines of: html Interesting link on the page This doesn't work becauase the page is now fixed, and there is nothing to scroll... Instead, we now use the touchmove again. The problem with this last time was that this disabled all touch move events. This is obviously not good. Luckily, we already have a concept of ""safe containers"". This is what we use for the outside click behaviour as well. Basically in a Dialog, your Dialog.Panel is the safe container. But also third party DOM elements that are rendered inside that Panel (or as a sibling of the Dialog, but not your main app). We can re-use this knowledge of ""safe containers"", and only cancel the touchmove behaviour if this didn't happen in any of the safe containers. update changelog"
99,Fix FocusTrap escape due to strange tabindex values (#2093)," sort DOM nodes using tabIndex first  It will still keep the same DOM order if tabIndex matches, thanks to stable sorts!  refactor focusIn API  All the arguments resulted in usage like focusIn(container, Focus.First, true, null), and to make things worse, we need to add something else to this list in the future. Instead, let's keep the container and the type of Focus as known params, all the other things can sit in an options object.  fix FocusTrap escape due to strange tabindex values  This code will now ensure that we can't escape the FocusTrap if you use <tab> and you happen to tab to an element outside of the FocusTrap because the next item in line happens to be outside of the FocusTrap and we never hit any of the focus guard elements. How it works is as follows:  The onBlur is implemented on the FocusTrap itself, this will give    us some information in the event itself. e.target is the element that is being blurred (think of it as from) e.currentTarget is the element with the event listener (the dialog) e.relatedTarget is the element we are going to (think of it as to) If the blur happened due to a <tab> or <shift>+<tab>, then we    will move focus back inside the FocusTrap, and go from the e.target    to the next or previous value. If the blur happened programmatically (so no tab keys are involved,    aka no direction is known), then the focus is restored to the    e.target value.  Fixes: #1656  update changelog",Fix FocusTrap escape due to strange tabindex values (#2093),"sort DOM nodes using tabIndex first It will still keep the same DOM order if tabIndex matches, thanks to stable sorts! refactor focusIn API All the arguments resulted in usage like focusIn(container, Focus.First, true, null), and to make things worse, we need to add something else to this list in the future. Instead, let's keep the container and the type of Focus as known params, all the other things can sit in an options object. fix FocusTrap escape due to strange tabindex values This code will now ensure that we can't escape the FocusTrap if you use  and you happen to tab to an element outside of the FocusTrap because the next item in line happens to be outside of the FocusTrap and we never hit any of the focus guard elements. How it works is as follows: The onBlur is implemented on the FocusTrap itself, this will give    us some information in the event itself. e.target is the element that is being blurred (think of it as from) e.currentTarget is the element with the event listener (the dialog) e.relatedTarget is the element we are going to (think of it as to) If the blur happened due to a  or +, then we    will move focus back inside the FocusTrap, and go from the e.target    to the next or previous value. If the blur happened programmatically (so no tab keys are involved,    aka no direction is known), then the focus is restored to the    e.target value. Fixes: #1656 update changelog"
100,Fix displayValue syncing when Combobox.Input is unmounted and re-mounted in different trees (#2090)," simplify currentDisplayValue calculation  Always calculate the currentDisplayValue, and only apply it if the user is not typing. In all other cases it can be applied (e.g.: when the value changes from the outside, inside or on reset)  update changelog",Fix displayValue syncing when Combobox.Input is unmounted and re-mounted in different trees (#2090),"simplify currentDisplayValue calculation Always calculate the currentDisplayValue, and only apply it if the user is not typing. In all other cases it can be applied (e.g.: when the value changes from the outside, inside or on reset) update changelog"
101,Fix regression where displayValue crashes (#2087)," fix regression where displayValue crashes  It regressed in the sense that it now uses displayValue for the defaultValue as well, but if nothing is passed it would crash. Right now, it makes sure to only run the displayValue value on the actual value and the actual default value if they are not undefined. Note: if your displayValue is implemented like (value) => value.name, and your value is passed as null, it will still crash (as expected) because then you are in charge of rendering something else than null. If we would ""fix"" this, then no value can be rendered instead of null. Fixes: #2084  update changelog",Fix regression where displayValue crashes (#2087),"fix regression where displayValue crashes It regressed in the sense that it now uses displayValue for the defaultValue as well, but if nothing is passed it would crash. Right now, it makes sure to only run the displayValue value on the actual value and the actual default value if they are not undefined. Note: if your displayValue is implemented like (value) => value.name, and your value is passed as null, it will still crash (as expected) because then you are in charge of rendering something else than null. If we would ""fix"" this, then no value can be rendered instead of null. Fixes: #2084 update changelog"
102,My grand contribution to this software (#2086),,My grand contribution to this software (#2086),
103,1.7.5 - @headlessui/vue,,1.7.5 - @headlessui/vue,
104,1.7.5 - @headlessui/react,,1.7.5 - @headlessui/react,
105,Allow clicks inside dialog panel when target is inside shadow root (#2079),  Allow clicks inside dialog panel when target is inside shadow root   fixup   Update changelog ,Allow clicks inside dialog panel when target is inside shadow root (#2079),Allow clicks inside dialog panel when target is inside shadow root fixup Update changelog
106,Ignore mouse move/leave events when the cursor hasn’t moved (#2069), Ignore mouse move/leave events when the cursor hasn’t moved  A mouse enter / leave event where the cursor hasn’t moved happen only because of: - Scrolling - The container moved   Fix linting errors   Update changelog   wip   Fix tests   fix linting error   Tweak tests to bypass tracked pointer checks   Fixup   Add stuff   Fix build script   fix stuff   wip ,Ignore mouse move/leave events when the cursor hasn’t moved (#2069),Ignore mouse move/leave events when the cursor hasn’t moved A mouse enter / leave event where the cursor hasn’t moved happen only because of: - Scrolling - The container moved Fix linting errors Update changelog wip Fix tests fix linting error Tweak tests to bypass tracked pointer checks Fixup Add stuff Fix build script fix stuff wip
107,Fix Dialog unmounting problem due to incorrect transitioncancel event in the Transition component on Android (#2071)," remove transitioncancel logic  On Desktop Sarai, Chrome, and on mobile iOS Safari the transitioncancel is never called on outside click of the Dialog. However, on mobile Android Chrome it is called, and the transitionend is never triggered for some reason. According to the MDN docs:  If the transitioncancel event is fired, the transitionend event will not fire. — https://developer.mozilla.org/en-US/docs/Web/API/Element/transitioncancel_event  When testing this, I never got into the transitionend when I got into the transitioncancel first. But, once I removed the transitioncancel logic, the transitionend code was being called. The code is now both simpler, and works again. The nice part is that we never did anything with the cancel event. We marked it as done using the Reason.Cancelled and that's about it.   cleanup transition completion Reason   update changelog ",Fix Dialog unmounting problem due to incorrect transitioncancel event in the Transition component on Android (#2071),"remove transitioncancel logic On Desktop Sarai, Chrome, and on mobile iOS Safari the transitioncancel is never called on outside click of the Dialog. However, on mobile Android Chrome it is called, and the transitionend is never triggered for some reason. According to the MDN docs: If the transitioncancel event is fired, the transitionend event will not fire. — link When testing this, I never got into the transitionend when I got into the transitioncancel first. But, once I removed the transitioncancel logic, the transitionend code was being called. The code is now both simpler, and works again. The nice part is that we never did anything with the cancel event. We marked it as done using the Reason.Cancelled and that's about it. cleanup transition completion Reason update changelog"
108,Improve SSR for Tabs in Vue (#2068),  improve SSR for Tabs in Vue   update changelog ,Improve SSR for Tabs in Vue (#2068),improve SSR for Tabs in Vue update changelog
109,0.1.2 - @headlessui/tailwindcss,,0.1.2 - @headlessui/tailwindcss,
110,Improve ListboxOption and ComboboxOption types (#2067),  improve ListboxOption and ComboboxOption types   update changelog ,Improve ListboxOption and ComboboxOption types (#2067),improve ListboxOption and ComboboxOption types update changelog
111,Add null as a valid type for Listbox and Combobox in Vue (#2064),  add null as a valid type for Listbox and Combobox in Vue   update changelog ,Add null as a valid type for Listbox and Combobox in Vue (#2064),add null as a valid type for Listbox and Combobox in Vue update changelog
112,Allow passing in your own id prop (#2060), accept id as a prop where it is currently hardcoded (React)  Continuation of #2020 Co-authored-by: Olivier Louvignes olivier@mgcrea.io   accept id as a prop where it is currently hardcoded (Vue)   update changelog   apply React's hook rules   Co-authored-by: Olivier Louvignes olivier@mgcrea.io,Allow passing in your own id prop (#2060),accept id as a prop where it is currently hardcoded (React) Continuation of #2020 Co-authored-by: Olivier Louvignes olivier@mgcrea.io accept id as a prop where it is currently hardcoded (Vue) update changelog apply React's hook rules Co-authored-by: Olivier Louvignes olivier@mgcrea.io
113,Apply enter and enterFrom classes in SSR for Transition component (#2059), apply enter and enterFrom classes in SSR  This only happens on the server when show=true and appear=true. This will guarantee that the class is already set to the correct value before the transition happens. It worked before if you moved your classes from enterFrom to className because that prop was SSR'd.  update changelog,Apply enter and enterFrom classes in SSR for Transition component (#2059),apply enter and enterFrom classes in SSR This only happens on the server when show=true and appear=true. This will guarantee that the class is already set to the correct value before the transition happens. It worked before if you moved your classes from enterFrom to className because that prop was SSR'd. update changelog
114,Fix crash when using multiple mode without value prop (uncontrolled) for Listbox and Combobox components (#2058), ensure value in multiple mode is always an array  In case nothing or undefined was passed.  update changelog,Fix crash when using multiple mode without value prop (uncontrolled) for Listbox and Combobox components (#2058),ensure value in multiple mode is always an array In case nothing or undefined was passed. update changelog
115,Improve syncing of the Combobox.Input value (#2042),"  make combobox playgrounds in React and Vue similar   syncing of the input should happen when the value changes internally or externally   I also got rid of the manually dispatching of the change event if the value changes from internally. I think the correct mental model is: - That the Combobox.Input value should change if the selected value   changes from the outside or from the inside.   - Note: It should not do that if you are currently typing (once you     choose a new value it will re-sync, once you reset (escape / outside     click) it will also sync again). - The onChange/onInput of the Combobox.Input itself should only be   called if you as the user type something. Not when the value is   ""synced"" based on the selected value. We were currently manually   dispatching events which works (to a certain extend) but smelled a bit   fishy to me. The manual dispatching of events tried to solve an issue (https://github.com/tailwindlabs/headlessui/issues/1875), but I think this can be solved in 2 other ways that make a bit more sense:  (Today) Use the onBlur on the input to reset the query value to filter    options.  (In the future)  Use an exposed onClose (or similar) event to reset    your query value.   update changelog   ignore flakey test ",Improve syncing of the Combobox.Input value (#2042),"make combobox playgrounds in React and Vue similar syncing of the input should happen when the value changes internally or externally I also got rid of the manually dispatching of the change event if the value changes from internally. I think the correct mental model is: - That the Combobox.Input value should change if the selected value   changes from the outside or from the inside.   - Note: It should not do that if you are currently typing (once you     choose a new value it will re-sync, once you reset (escape / outside     click) it will also sync again). - The onChange/onInput of the Combobox.Input itself should only be   called if you as the user type something. Not when the value is   ""synced"" based on the selected value. We were currently manually   dispatching events which works (to a certain extend) but smelled a bit   fishy to me. The manual dispatching of events tried to solve an issue (link), but I think this can be solved in 2 other ways that make a bit more sense: (Today) Use the onBlur on the input to reset the query value to filter    options. (In the future)  Use an exposed onClose (or similar) event to reset    your query value. update changelog ignore flakey test"
116,Move tailwindcss to devDependencies (#2040),  move tailwindcss to devDependencies   update changelog ,Move tailwindcss to devDependencies (#2040),move tailwindcss to devDependencies update changelog
117,Ensure shift+home and shift+end works as expected in the Combobox.Input component (#2024)," ensure shift+home and shift+end works as expected  While testing with a normal input, the Home and End keys don't do anything on their own, so therefore using them to go to the first or last item respectively is still a good solution. However, shift+home and shift+end will do something, it will select the text in the input.  update changelog",Ensure shift+home and shift+end works as expected in the Combobox.Input component (#2024),"ensure shift+home and shift+end works as expected While testing with a normal input, the Home and End keys don't do anything on their own, so therefore using them to go to the first or last item respectively is still a good solution. However, shift+home and shift+end will do something, it will select the text in the input. update changelog"
118,Ensure Popover doesn't crash when focus is going to window (#2019),  ensure Popover doesn't crash when focus is going to window   update changelog ,Ensure Popover doesn't crash when focus is going to window (#2019),ensure Popover doesn't crash when focus is going to window update changelog
119,Add warning when using <Popover.Button /> multiple times (#2007),  add warning when using <Popover.Button /> multiple times   update changelog ,Add warning when using  multiple times (#2007),add warning when using  multiple times update changelog
120,Reset form-like components when the parent <form> resets (#2004),"  add reset button to form example   refactor React Listbox   This splitsup the raw [state, dispatch] to separate useActions and useData hooks. This allows us to make the actions themselves simpler and include logic that doesn't really belong in the reducer itself. This also allows us to expose data via the useData hook that doesn't belong in the state exposed from the useReducer hook. E.g.: we used to store a propsRef from the root Listbox, and update the ref with the new props in a useEffect. Now, we will just expose that information directly via the useData hook. This simplifies the code, removes useEffect's and so on.  refactor Tabs, ensure function reference stays the same  If the isControlled value changes, then the references to all the functions changed. Now they won't because of the useEvent hooks.   type the actions abg similar to how we type the data bag   refactor RadioGroup to use useData/useActions hooks   reset Listbox to defaultValue on form reset   reset Combobox to defaultValue on form reset   reset RadioGroup to defaultValue on form reset   reset Switch to defaultChecked on form reset   port combinations/form playground example to Vue   update changelog ",Reset form-like components when the parent  resets (#2004),"add reset button to form example refactor React Listbox This splitsup the raw [state, dispatch] to separate useActions and useData hooks. This allows us to make the actions themselves simpler and include logic that doesn't really belong in the reducer itself. This also allows us to expose data via the useData hook that doesn't belong in the state exposed from the useReducer hook. E.g.: we used to store a propsRef from the root Listbox, and update the ref with the new props in a useEffect. Now, we will just expose that information directly via the useData hook. This simplifies the code, removes useEffect's and so on. refactor Tabs, ensure function reference stays the same If the isControlled value changes, then the references to all the functions changed. Now they won't because of the useEvent hooks. type the actions abg similar to how we type the data bag refactor RadioGroup to use useData/useActions hooks reset Listbox to defaultValue on form reset reset Combobox to defaultValue on form reset reset RadioGroup to defaultValue on form reset reset Switch to defaultChecked on form reset port combinations/form playground example to Vue update changelog"
121,1.7.4,,1.7.4,
122,Add client-only to mark everything as client components (#1981), add client-only to mark everything as client components  This should improve the error messages when using Headless UI in a Next.js 13+ repo instead of getting a cryptic error message that createContext doesn't exist.  update changelog,Add client-only to mark everything as client components (#1981),add client-only to mark everything as client components This should improve the error messages when using Headless UI in a Next.js 13+ repo instead of getting a cryptic error message that createContext doesn't exist. update changelog
123,fix: the order of compositionend events varies by browser (#1890),  fix: the order of compositionend events varies by browser   apply our style conventions   Co-authored-by: Robin Malfait malfait.robin@gmail.com,fix: the order of compositionend events varies by browser (#1890),fix: the order of compositionend events varies by browser apply our style conventions Co-authored-by: Robin Malfait malfait.robin@gmail.com
124,fix(RadioGroup): defaultValue type definition (#1920),,fix(RadioGroup): defaultValue type definition (#1920),
125,Fire user’s onChange handler when we update the combobox input value internally (#1916),  Fire user’s onChange handler when we update the input value internally   Update changelog   Fix CS ,Fire user’s onChange handler when we update the combobox input value internally (#1916),Fire user’s onChange handler when we update the input value internally Update changelog Fix CS
126,Pass default slot instead of raw children to components (#1915), Pass default slot instead of raw children to components  This is essentially how the internal implementation of <component> works. This works even for element VNodes.  Update changelog,Pass default slot instead of raw children to components (#1915),Pass default slot instead of raw children to components This is essentially how the internal implementation of  works. This works even for element VNodes. Update changelog
127,"Fix useOutsideClick, add improvements for ShadowDOM (#1914)", Fix useOutsideClick not closing when clicking in ShadowDOM  https://github.com/tailwindlabs/headlessui/pull/1876#issuecomment-1264742366   use getRootNode in useOutsideClick for Vue   update changelog   run prettier   Co-authored-by: Theodore Messinezis 7229472+theomessin@users.noreply.github.com,"Fix useOutsideClick, add improvements for ShadowDOM (#1914)",Fix useOutsideClick not closing when clicking in ShadowDOM link use getRootNode in useOutsideClick for Vue update changelog run prettier Co-authored-by: Theodore Messinezis 7229472+theomessin@users.noreply.github.com
128,Warn when changing Combobox between controlled and uncontrolled (#1878),,Warn when changing Combobox between controlled and uncontrolled (#1878),
129,Expose close function for Menu and Menu.Item components (#1897)," expose close function for Menu and Menu.Item components  The Menu will already automatically close if you invoke the Menu.Item (which is typically an a or a button). However you have control over this, so if you add an explicit onClick={e => e.preventDefault()} then we respect that and don't execute the default behavior, ergo closing the menu. The problem occurs when you are using another component like the Inertia Link component, that does have this e.preventDefault() built-in to guarantee SPA-like page transitions without refreshing the browser. Because of this, the menu will never close (unless you go to a totally different page where the menu is not present of course). This is where the explicit close function comes in, now you can use that function to ""force"" close a menu, if your 3rd party tool already bypassed the default behaviour. This API is also how we do it in the Popover component for scenario's where you can't rely on the default behaviour.  update changelog",Expose close function for Menu and Menu.Item components (#1897),"expose close function for Menu and Menu.Item components The Menu will already automatically close if you invoke the Menu.Item (which is typically an a or a button). However you have control over this, so if you add an explicit onClick={e => e.preventDefault()} then we respect that and don't execute the default behavior, ergo closing the menu. The problem occurs when you are using another component like the Inertia Link component, that does have this e.preventDefault() built-in to guarantee SPA-like page transitions without refreshing the browser. Because of this, the menu will never close (unless you go to a totally different page where the menu is not present of course). This is where the explicit close function comes in, now you can use that function to ""force"" close a menu, if your 3rd party tool already bypassed the default behaviour. This API is also how we do it in the Popover component for scenario's where you can't rely on the default behaviour. update changelog"
130,Fix <Popover.Button as={Fragment} /> crash (#1889), prevent infinite loop  When you use as={Fragment} an unmount and remount can happen. This means that the ref gets called with null for the unmount and HTMLButtonElement for the mount. This keeps toggling which results in an infinite loop and eventually a Maximum callback size exceeded issue. This ensures that we only set the button if we have a button.  update changelog,Fix  crash (#1889),prevent infinite loop When you use as={Fragment} an unmount and remount can happen. This means that the ref gets called with null for the unmount and HTMLButtonElement for the mount. This keeps toggling which results in an infinite loop and eventually a Maximum callback size exceeded issue. This ensures that we only set the button if we have a button. update changelog
131,1.7.3,,1.7.3,
132,Fix Tab incorrectly activating on focus event (#1887)," rework Tabs so that they don't change on focus  The ""change on focus"" was an incorrect implementation detail that made it a bit easier but this causes a problem as seen in #1858. If you want to conditionally check if you want to change the tab or note (e.g. by using window.confirm) then the focus is lost while the popup is shown. Regardless of your choice, the browser will re-focus the Tab therefore asking you again what you want to do. This fixes that by only activating the tab if needed while using arrow keys or when you click the tab (not when it is focused).  update changelog",Fix Tab incorrectly activating on focus event (#1887),"rework Tabs so that they don't change on focus The ""change on focus"" was an incorrect implementation detail that made it a bit easier but this causes a problem as seen in #1858. If you want to conditionally check if you want to change the tab or note (e.g. by using window.confirm) then the focus is lost while the popup is shown. Regardless of your choice, the browser will re-focus the Tab therefore asking you again what you want to do. This fixes that by only activating the tab if needed while using arrow keys or when you click the tab (not when it is focused). update changelog"
133,Fix useOutsideClick swallowing events inside ShadowDOM (#1886),  check inside shadow dom for use-outside-click   update changelog   Co-authored-by: Raphael Melloni raphael.melloni@nortal.com,Fix useOutsideClick swallowing events inside ShadowDOM (#1886),check inside shadow dom for use-outside-click update changelog Co-authored-by: Raphael Melloni raphael.melloni@nortal.com
134,Fix crash when children are undefined (#1885),  ensure children always exist   update changelog ,Fix crash when children are undefined (#1885),ensure children always exist update changelog
135,update changelog,,update changelog,
136,Improve Portal detection for Popover components (#1842),  improve Popover heuristics for detecting being inside a Portal   improve performance of checks   make it work in Vue   verify behaviour in tests ,Improve Portal detection for Popover components (#1842),improve Popover heuristics for detecting being inside a Portal improve performance of checks make it work in Vue verify behaviour in tests
137,Fix use of undefined and displayValue in Combobox (#1865),  Work around Vue multi-source + undefined bug   Update changelog ,Fix use of undefined and displayValue in Combobox (#1865),Work around Vue multi-source + undefined bug Update changelog
138,Internal: Refactor Vue playground (#1864),  Add dynamic routes to Vue playground   Simplify   Upgrade to Vite 3.0   Use TypeScript ,Internal: Refactor Vue playground (#1864),Add dynamic routes to Vue playground Simplify Upgrade to Vite 3.0 Use TypeScript
139,1.7.2,,1.7.2,
140,Ensure we handle the static prop in Tab.Panel components correctly (#1856),  ensure we handle static panels   update changelog ,Ensure we handle the static prop in Tab.Panel components correctly (#1856),ensure we handle static panels update changelog
141,Prevent option selection in ComboboxInput while composing (#1850),  Fix should do nothing when event is fired within a composing session   update changelog   link to PR instead of issue   Co-authored-by: Robin Malfait malfait.robin@gmail.com,Prevent option selection in ComboboxInput while composing (#1850),Fix should do nothing when event is fired within a composing session update changelog link to PR instead of issue Co-authored-by: Robin Malfait malfait.robin@gmail.com
142,1.7.1,,1.7.1,
143,Remove forceRerender from Tab component (#1846)," remove forceRerender code  This was necessary to ensure the Panel and the Tab were properly connected with eachother because it could happen that the Tab renders but the corresponding Panel is not the active one which means that it didn't have a DOM node and no id attached. Whenever new Tab became active, it rerendered but the Panel wasn't available yet, after that the Panel rendered and an id was available but the actual Tab was already rendered so there was no link between them. We then forced a re-render because now the Panel does have a DOM node ref attached and the aria-labelledby could be filled in. However, in #1837 we fixed an issue where the order of Tab elements with their corresponding Panel elements weren't always correct. To fix this we ensured that the Panel always rendered a <Hidden /> component which means that a DOM node is always available. This now means that we can get rid of the forceRerender.  update changelog",Remove forceRerender from Tab component (#1846),"remove forceRerender code This was necessary to ensure the Panel and the Tab were properly connected with eachother because it could happen that the Tab renders but the corresponding Panel is not the active one which means that it didn't have a DOM node and no id attached. Whenever new Tab became active, it rerendered but the Panel wasn't available yet, after that the Panel rendered and an id was available but the actual Tab was already rendered so there was no link between them. We then forced a re-render because now the Panel does have a DOM node ref attached and the aria-labelledby could be filled in. However, in #1837 we fixed an issue where the order of Tab elements with their corresponding Panel elements weren't always correct. To fix this we ensured that the Panel always rendered a  component which means that a DOM node is always available. This now means that we can get rid of the forceRerender. update changelog"
144,Ensure Combobox.Label is properly linked when rendered after Combobox.Button and Combobox.Input components (#1838), ensure Combbox.Label is properly linked when rendered after other components  Even when rendered after the Combobox.Input / Combobox.Button  update changelog,Ensure Combobox.Label is properly linked when rendered after Combobox.Button and Combobox.Input components (#1838),ensure Combbox.Label is properly linked when rendered after other components Even when rendered after the Combobox.Input / Combobox.Button update changelog
145,"Ensure Tab order stays consistent, and the currently active Tab stays active (#1837)"," ensure tabs order stays consistent  This ensures that whenever you insert or delete tabs before the current tab, that the current tab stays active with the proper panel. To do this we had to start rendering the non-visible panels as well, but we used the Hidden component already which is position fixed and completely hidden so this should not break layouts where using flexbox or grid.   update changelog   fix TypeScript issue ","Ensure Tab order stays consistent, and the currently active Tab stays active (#1837)","ensure tabs order stays consistent This ensures that whenever you insert or delete tabs before the current tab, that the current tab stays active with the proper panel. To do this we had to start rendering the non-visible panels as well, but we used the Hidden component already which is position fixed and completely hidden so this should not break layouts where using flexbox or grid. update changelog fix TypeScript issue"
146,Add <fieldset disabled> check to radio group options in React (#1835),  wip   Update changelog ,Add  check to radio group options in React (#1835),wip Update changelog
147,Improve iOS scroll locking (#1830)," use a simpler position: fixed approach to prevent scroll locking  This isn't super ideal, but just preventing the default behavior on the entire document while touchmove-ing isn't ideal either because then you can't scroll inside the dialog or on the backdrop if your dialog panel is larger than the viewport. Again, this is not 100% correct, but it is better because you will be able to scroll the dialog, and not the body.  update changelog",Improve iOS scroll locking (#1830),"use a simpler position: fixed approach to prevent scroll locking This isn't super ideal, but just preventing the default behavior on the entire document while touchmove-ing isn't ideal either because then you can't scroll inside the dialog or on the backdrop if your dialog panel is larger than the viewport. Again, this is not 100% correct, but it is better because you will be able to scroll the dialog, and not the body. update changelog"
148,@headlessui/tailwindcss — 0.1.1,,@headlessui/tailwindcss — 0.1.1,
149,1.7.0,,1.7.0,
150,Tweak changelogs,,Tweak changelogs,
151,"Fix ""blank"" screen on initial load of Transition component (#1823)","  use a ""cancellable"" microTask   update changelog ","Fix ""blank"" screen on initial load of Transition component (#1823)","use a ""cancellable"" microTask update changelog"
152,Fix maximum call stack size exceeded error on Tab component when using as={Fragment} (#1826),,Fix maximum call stack size exceeded error on Tab component when using as={Fragment} (#1826),
153,fix incorrect links in CHANGELOGs,,fix incorrect links in CHANGELOGs,
154,Improve scroll lock on iOS (#1824),  improve Dialog scroll lock on iOS   add Dialog example to playground that's scrollable   update changelog ,Improve scroll lock on iOS (#1824),improve Dialog scroll lock on iOS add Dialog example to playground that's scrollable update changelog
155,Expose the value from the Combobox and Listbox components render prop (#1822),  expose the value for Combobox and Listbox   update changelog ,Expose the value from the Combobox and Listbox components render prop (#1822),expose the value for Combobox and Listbox update changelog
156,Fix ref stealing from children (#1820)," fix ref stealing  When a higher-level component (like Transition) provides a ref to its child component, then it will override the ref that was potentially already on the child. This will make sure that these are merged together correctly. Fixes: #985  update changelog",Fix ref stealing from children (#1820),"fix ref stealing When a higher-level component (like Transition) provides a ref to its child component, then it will override the ref that was potentially already on the child. This will make sure that these are merged together correctly. Fixes: #985 update changelog"
157,Fix nullable by prop for combobox and radio group (#1815),  Fix nullable by prop for combobox and radio group   Update changelog ,Fix nullable by prop for combobox and radio group (#1815),Fix nullable by prop for combobox and radio group Update changelog
158,Allow the by prop (as a string) to handle null values (#1814),  Allow the by prop (as a string) to handle null values   Update changelog ,Allow the by prop (as a string) to handle null values (#1814),Allow the by prop (as a string) to handle null values Update changelog
159,Improve accessibility when announcing Listbox.Option and Combobox.Option components (#1812)," ensure that aria-selected is explicitly set to false  The WAI-ARIA Best Practices don't recommend this and prefer aria-selected: true or undefined (aka not existing when it is ""false""). However in practice, both MacOS VoiceOver and NVDA experience strange issues if you don't do this (e.g.: everything before the selected item is also selected)   update tests to ensure we are checking for aria-selected=false   update changelog ",Improve accessibility when announcing Listbox.Option and Combobox.Option components (#1812),"ensure that aria-selected is explicitly set to false The WAI-ARIA Best Practices don't recommend this and prefer aria-selected: true or undefined (aka not existing when it is ""false""). However in practice, both MacOS VoiceOver and NVDA experience strange issues if you don't do this (e.g.: everything before the selected item is also selected) update tests to ensure we are checking for aria-selected=false update changelog"
160,update changelog,,update changelog,
161,Ensure enter transitions work when using unmount={false} (#1811),  ensure we never start transitioning while the node is still hidden   update changelog ,Ensure enter transitions work when using unmount={false} (#1811),ensure we never start transitioning while the node is still hidden update changelog
162,Fix Transition component's incorrect cleanup and order of events (#1803),  improve tracking of transitionableChildren   remove weird outlier snapshots   If anything is still wrong the tests will still fail but the diffs will be easier to read.   remove event handling from useTransition   handle before/after events in Transition directly   fix incorrect logic bug in tests   add very explicit test for transition event order   ignore flakey tests for now   We will get back to these!   ensure cancellation of transitions works properly   update changelog ,Fix Transition component's incorrect cleanup and order of events (#1803),improve tracking of transitionableChildren remove weird outlier snapshots If anything is still wrong the tests will still fail but the diffs will be easier to read. remove event handling from useTransition handle before/after events in Transition directly fix incorrect logic bug in tests add very explicit test for transition event order ignore flakey tests for now We will get back to these! ensure cancellation of transitions works properly update changelog
163,Stop scrolling when hitting end of focus trap (#1789),  wip   wip   fix it   fixit   update changelog ,Stop scrolling when hitting end of focus trap (#1789),wip wip fix it fixit update changelog
164,Only restore focus to the Menu.Button if necessary when activating a Menu.Option (#1782), only restore focus to the Menu Button if necessary  This will check whether the focus got moved to somewhere else or not once we activate an item via click or pressing enter. Pressing escape will still move focus to the Menu Button.  update changelog,Only restore focus to the Menu.Button if necessary when activating a Menu.Option (#1782),only restore focus to the Menu Button if necessary This will check whether the focus got moved to somewhere else or not once we activate an item via click or pressing enter. Pressing escape will still move focus to the Menu Button. update changelog
165,Improve the types of the Combobox component (#1761)," improve types of Combobox  Now given the multiple and/or nullable props we ensure that the types for the value, defaultValue, onChange, by, render prop, ... are all correct. You will also be able to easily tell which type to use instead of inferring it by doing something like this: ```tsx <Combobox   value={...}   onChange={...}   ...  ...  ```   update changelog",Improve the types of the Combobox component (#1761),"improve types of Combobox Now given the multiple and/or nullable props we ensure that the types for the value, defaultValue, onChange, by, render prop, ... are all correct. You will also be able to easily tell which type to use instead of inferring it by doing something like this: ```tsx <Combobox   value={...}   onChange={...}   ... ... ``` update changelog"
166,Fix displayValue syncing problem (#1755),  ensure syncInputValue is updated correctly   WIP   WIP   Don’t resync on open   Fix react value syncing   update   Add comment   Port new setup over to Vue   Remove inputPropsRef   We hardly knew ye   Remove repro   Cleanup   Update changelog   Co-authored-by: Robin Malfait malfait.robin@gmail.com,Fix displayValue syncing problem (#1755),ensure syncInputValue is updated correctly WIP WIP Don’t resync on open Fix react value syncing update Add comment Port new setup over to Vue Remove inputPropsRef We hardly knew ye Remove repro Cleanup Update changelog Co-authored-by: Robin Malfait malfait.robin@gmail.com
167,"Only select the active option when using ""singular"" mode (#1750)","  only select the active option when using ""singular"" mode   update changelog ","Only select the active option when using ""singular"" mode (#1750)","only select the active option when using ""singular"" mode update changelog"
168,Ensure Disclosure.Panel is properly linked (#1747),  ensure Disclosure.Panel is properly linked   update changelog ,Ensure Disclosure.Panel is properly linked (#1747),ensure Disclosure.Panel is properly linked update changelog
169,fixes tailwindlabs/headlessui#1733 (#1734),,fixes tailwindlabs/headlessui#1733 (#1734),
170,Fix person removal from Combobox/Listbox demos (#1603),  Fix person removal from Combobox/Listbox demos   Reset query on focus for Combobox demo with multiple items ,Fix person removal from Combobox/Listbox demos (#1603),Fix person removal from Combobox/Listbox demos Reset query on focus for Combobox demo with multiple items
171,Allow MouseEventHandler types to passed close from Popovers (#1696),  fix: adds the MouseEventHandler type to close   WIP   WIP   Update changelog   Co-authored-by: Jordan Pittman jordan@cryptica.me,Allow MouseEventHandler types to passed close from Popovers (#1696),fix: adds the MouseEventHandler type to close WIP WIP Update changelog Co-authored-by: Jordan Pittman jordan@cryptica.me
172,Improve Combobox re-opening keyboard issue on mobile (#1732)," prevent re-focusing Combobox Input after choosing selection  On mobile this gives a bit of annoying results where after choosing an option, the keyboard is shown again because the input is focused again.  update changelog",Improve Combobox re-opening keyboard issue on mobile (#1732),"prevent re-focusing Combobox Input after choosing selection On mobile this gives a bit of annoying results where after choosing an option, the keyboard is shown again because the input is focused again. update changelog"
173,update changelog,,update changelog,
174,Make form components uncontrollable (#1683)," implement uncontrolled form components  A few versions ago we introduced compatibility with the native form element. This means that behind the scenes we render hidden inputs that are kept in sync which allows you to submit your normal form and get data via new FormData(event.currentTarget). Before this change every form related component (Switch, RadioGroup, Listbox and Combobox) always had to be passed a value and an onChange regardless of this change. This change will allow you to not even use the value and the onChange at all and keep it completely uncontrolled. This has some changes:  value is made optional onChange is made optional (but will still be called if passed   regardless of being controlled or uncontrolled) defaultValue got added so that you can still pre-fill your values   with known values. value render prop got exposed so that you can still use this while   rendering.  This should also make it completely compatible with tools like Remix without wiring up your own state.   update example combinations/form playground to use uncontrolled components   improve types, add missing render prop arguments   add tests for uncontrolled components (React)   implement uncontrolled form elements in Vue ",Make form components uncontrollable (#1683),"implement uncontrolled form components A few versions ago we introduced compatibility with the native form element. This means that behind the scenes we render hidden inputs that are kept in sync which allows you to submit your normal form and get data via new FormData(event.currentTarget). Before this change every form related component (Switch, RadioGroup, Listbox and Combobox) always had to be passed a value and an onChange regardless of this change. This change will allow you to not even use the value and the onChange at all and keep it completely uncontrolled. This has some changes: value is made optional onChange is made optional (but will still be called if passed   regardless of being controlled or uncontrolled) defaultValue got added so that you can still pre-fill your values   with known values. value render prop got exposed so that you can still use this while   rendering. This should also make it completely compatible with tools like Remix without wiring up your own state. update example combinations/form playground to use uncontrolled components improve types, add missing render prop arguments add tests for uncontrolled components (React) implement uncontrolled form elements in Vue"
175,Improve TypeScript 4.7 NodeNext compatibility (#1721),  update script to mass-update import/export statements   rewrite imports on .d.ts files   add idempotency comment ,Improve TypeScript 4.7 NodeNext compatibility (#1721),update script to mass-update import/export statements rewrite imports on .d.ts files add idempotency comment
176,Don’t overwrite element.focus on popover panels (#1719),  Don’t overwrite element.focus on popover panels   Update changelog   Add test   This test isn’t exactly right for JSDOM but it does mirror what we would do in the browser to reproduce the problem,Don’t overwrite element.focus on popover panels (#1719),Don’t overwrite element.focus on popover panels Update changelog Add test This test isn’t exactly right for JSDOM but it does mirror what we would do in the browser to reproduce the problem
177,Ensure by comparison is used in multiple mode (#1717),  use the compare function in multiple mode   add tests to verify fix of incorrect by behaviour   improve TypeScript types for the by prop   update changelog ,Ensure by comparison is used in multiple mode (#1717),use the compare function in multiple mode add tests to verify fix of incorrect by behaviour improve TypeScript types for the by prop update changelog
178,Fix incorrect scrolling to the bottom when opening a Dialog (#1716)," add ?raw option to playground  This will render the component as-is without the wrapper.  delay initial focus and make consistent between React and Vue  This will delay the initial focus and makes it consistent between React and Vue. Some explanation from within the code why this is happening: Delaying the focus to the next microtask ensures that a few    conditions are true:  The container is rendered Transitions could be started  If we don't do this, then focusing an element will immediately cancel    any transitions. This is not ideal because transitions will look    broken. There is an additional issue with doing this immediately. The    FocusTrap is used inside a Dialog, the Dialog is rendered inside of a    Portal and the Portal is rendered at the end of the document.body.    This means that the moment we call focus, the browser immediately    tries to focus the element, which will still be at the bodem    resulting in the page to scroll down. Delaying this will prevent the    page to scroll down entirely.  update test to reflect initial focus delay  Now that we are triggering the initial focus inside a queueMicroTask we have to make sure that our tests wait a frame so that the micro task could run, otherwise we will have incorrect results. Also make the implementation similar in React and Vue  update changelog",Fix incorrect scrolling to the bottom when opening a Dialog (#1716),"add ?raw option to playground This will render the component as-is without the wrapper. delay initial focus and make consistent between React and Vue This will delay the initial focus and makes it consistent between React and Vue. Some explanation from within the code why this is happening: Delaying the focus to the next microtask ensures that a few    conditions are true: The container is rendered Transitions could be started If we don't do this, then focusing an element will immediately cancel    any transitions. This is not ideal because transitions will look    broken. There is an additional issue with doing this immediately. The    FocusTrap is used inside a Dialog, the Dialog is rendered inside of a    Portal and the Portal is rendered at the end of the document.body.    This means that the moment we call focus, the browser immediately    tries to focus the element, which will still be at the bodem    resulting in the page to scroll down. Delaying this will prevent the    page to scroll down entirely. update test to reflect initial focus delay Now that we are triggering the initial focus inside a queueMicroTask we have to make sure that our tests wait a frame so that the micro task could run, otherwise we will have incorrect results. Also make the implementation similar in React and Vue update changelog"
179,Improve event handler merging (#1715)," improve event handler merging  This will ensure that an actual event is passed before checking the event.defaultPrevented. For React, we also have to make sure that we are not dealing with a SyntehticEvent. Thanks @Mookiepiece! Co-authored-by: =?UTF-8?q?=E5=BD=BC=E8=A1=93=E5=90=91?= 48076971+Mookiepiece@users.noreply.github.com  update changelog  Co-authored-by: =?UTF-8?q?=E5=BD=BC=E8=A1=93=E5=90=91?= 48076971+Mookiepiece@users.noreply.github.com",Improve event handler merging (#1715),"improve event handler merging This will ensure that an actual event is passed before checking the event.defaultPrevented. For React, we also have to make sure that we are not dealing with a SyntehticEvent. Thanks @Mookiepiece! Co-authored-by: =?UTF-8?q?=E5=BD=BC=E8=A1=93=E5=90=91?= 48076971+Mookiepiece@users.noreply.github.com update changelog Co-authored-by: =?UTF-8?q?=E5=BD=BC=E8=A1=93=E5=90=91?= 48076971+Mookiepiece@users.noreply.github.com"
180,Improve outside click on Safari iOS (#1712)," ensure outside click works on Safari in iOS  When tapping on an element that is not clickable (like a div), then the click and mousedown events will not reach the window.addEventListener('click') listeners. The only event that does that could be interesting for us is the pointerdown event. The issue with this one is that we then run into the big issue we ran in a few months ago where clicks on a scrollbar also fired while a click doesn't. This issue was not an issue in React land, the window.addEventListener('click') was fired even when tapping on a div. This was very very confusing, but we think this is because of the syntethic event system, where the event listener is added to the root of your application (E.g.: #app) and React manually bubbles the events. Because this is done manually, it does reach the window as well. The confusing part is, how does React convert a pointerdown event to a mousedown and click. There is no code for that in their codebase? Turns out they don't, and turns out the events do bubble, but up until the document, not the window. But since they are manually bubbling events it all makes sense. So the solution? Let's switch from window to document...   update Dialog example to use DialogPanel   update changelog ",Improve outside click on Safari iOS (#1712),"ensure outside click works on Safari in iOS When tapping on an element that is not clickable (like a div), then the click and mousedown events will not reach the window.addEventListener('click') listeners. The only event that does that could be interesting for us is the pointerdown event. The issue with this one is that we then run into the big issue we ran in a few months ago where clicks on a scrollbar also fired while a click doesn't. This issue was not an issue in React land, the window.addEventListener('click') was fired even when tapping on a div. This was very very confusing, but we think this is because of the syntethic event system, where the event listener is added to the root of your application (E.g.: #app) and React manually bubbles the events. Because this is done manually, it does reach the window as well. The confusing part is, how does React convert a pointerdown event to a mousedown and click. There is no code for that in their codebase? Turns out they don't, and turns out the events do bubble, but up until the document, not the window. But since they are manually bubbling events it all makes sense. So the solution? Let's switch from window to document... update Dialog example to use DialogPanel update changelog"
181,Don't scroll lock when a Transition + Dialog is mounted but hidden (#1681),  Refer to context for initial Transition Tree state   Update changelog ,Don't scroll lock when a Transition + Dialog is mounted but hidden (#1681),Refer to context for initial Transition Tree state Update changelog
182,Ensure controlled Tabs don't change automagically (#1680)," fix controlled tabs should not switch tabs  When the Tabs component is used ina a controlled way, then clicking on a tab should call the onChange callback, but it should not change the actual tab internally.  update changelog",Ensure controlled Tabs don't change automagically (#1680),"fix controlled tabs should not switch tabs When the Tabs component is used ina a controlled way, then clicking on a tab should call the onChange callback, but it should not change the actual tab internally. update changelog"
183,Resync input when display value changes (#1679),  Resync input when display value changes   Update changelog ,Resync input when display value changes (#1679),Resync input when display value changes Update changelog
184,Close Menu component when using tab key (#1673),"  menu should not trap focus for tab key   introduce focusFrom focus management utility   This is internal API, and the actual API is not 100% ideal. I started refactoring this in a separate branch but it got out of hand and touches a bit more pieces of the codebase that aren't related to this PR at all. The idea of this function is just so that we can go Next/Previous but from the given element not from the document.activeElement. This is important for this feature. We also bolted this ontop of the existing code which now means that we have this API: js focusIn([], Focus.Previouw, true, DOMNode) Luckily it's internal API only!  ensure closing via Tab works as expected  Just closing the Menu isn't 100% enough. If we do this, it means that when the Menu is open, we press shift+tab, then we go to the Menu.Button because the Menu.Items were the active element. The other way is also incorrect because it can happen if you have an <a> element as one of the Menu.Item elements then that <a> will receive focus, then the Menu will close unmounting the focused <a> and now that element is gone resulting in document.body being the active element. To fix this, we will make sure that we consider the Menu as 1 coherent component. This means that using <Tab> will now go to the next element after the <Menu.Button> once the Menu is closed. Shift+Tab will go to the element before the <Menu.Button> even though you are currently focused on the Menu.Items so depending on the timing you go to the Menu.Button or not. Considering the Menu as a single component it makes more sense use the elements before / after the Menu  update changelog  Co-authored-by: Enoch Riese enoch.riese@gmail.com",Close Menu component when using tab key (#1673),"menu should not trap focus for tab key introduce focusFrom focus management utility This is internal API, and the actual API is not 100% ideal. I started refactoring this in a separate branch but it got out of hand and touches a bit more pieces of the codebase that aren't related to this PR at all. The idea of this function is just so that we can go Next/Previous but from the given element not from the document.activeElement. This is important for this feature. We also bolted this ontop of the existing code which now means that we have this API: js focusIn([], Focus.Previouw, true, DOMNode) Luckily it's internal API only! ensure closing via Tab works as expected Just closing the Menu isn't 100% enough. If we do this, it means that when the Menu is open, we press shift+tab, then we go to the Menu.Button because the Menu.Items were the active element. The other way is also incorrect because it can happen if you have an  element as one of the Menu.Item elements then that  will receive focus, then the Menu will close unmounting the focused  and now that element is gone resulting in document.body being the active element. To fix this, we will make sure that we consider the Menu as 1 coherent component. This means that using  will now go to the next element after the  once the Menu is closed. Shift+Tab will go to the element before the  even though you are currently focused on the Menu.Items so depending on the timing you go to the Menu.Button or not. Considering the Menu as a single component it makes more sense use the elements before / after the Menu update changelog Co-authored-by: Enoch Riese enoch.riese@gmail.com"
185,Adjust outside click handling (#1667),  Don’t close dialog if opened during mouse up event   Don’t close dialog if drag starts inside dialog and ends outside dialog   Handle closing of nested dialogs that are always mounted   Fix focus trap restoration in Vue   Update changelog ,Adjust outside click handling (#1667),Don’t close dialog if opened during mouse up event Don’t close dialog if drag starts inside dialog and ends outside dialog Handle closing of nested dialogs that are always mounted Fix focus trap restoration in Vue Update changelog
186,Fix SSR support in Deno (#1671),  check typeof document in addition to typeof window   remove unused import   Extract SSR check to a central spot   Fix CS   Update changelog   Co-authored-by: Jordan Pittman jordan@cryptica.me,Fix SSR support in Deno (#1671),check typeof document in addition to typeof window remove unused import Extract SSR check to a central spot Fix CS Update changelog Co-authored-by: Jordan Pittman jordan@cryptica.me
187,Run tests for PRs,,Run tests for PRs,
188,"Revert ""prepare 1.6.7""",This reverts commit 9807e2ba7e75af456f19b6eac7d98862a0645bc2.,"Revert ""prepare 1.6.7""",This reverts commit 9807e2ba7e75af456f19b6eac7d98862a0645bc2.
189,1.6.7,,1.6.7,
190,prepare 1.6.7,,prepare 1.6.7,
191,Prevent cancelling transitions due to focus trap (#1664)," focus trap after transitions  Whenever you focus an element mid transition, the browser will abrublty stop/cancel the transition and it will do anything it can to focus the element. This has a very annoying side effect that this causes very abrubt transitions (instant) in some browsers. To fix this, we used to use el.focus({ preventScroll: true }) which works in Safari and it used to work in Chrome / Firefox, but there are probably other variables that we have to keep in mind here (didn't figure out why this used to work and not anymore). That said, instead of trying to fight the browser, we will now wait an animation frame before even trying to focus any elements.  update changelog",Prevent cancelling transitions due to focus trap (#1664),"focus trap after transitions Whenever you focus an element mid transition, the browser will abrublty stop/cancel the transition and it will do anything it can to focus the element. This has a very annoying side effect that this causes very abrubt transitions (instant) in some browsers. To fix this, we used to use el.focus({ preventScroll: true }) which works in Safari and it used to work in Chrome / Firefox, but there are probably other variables that we have to keep in mind here (didn't figure out why this used to work and not anymore). That said, instead of trying to fight the browser, we will now wait an animation frame before even trying to focus any elements. update changelog"
192,"Revert ""prepare 1.6.6""",This reverts commit 06df02a1586352ce0e7963a177810ad8f4f37dd9.,"Revert ""prepare 1.6.6""",This reverts commit 06df02a1586352ce0e7963a177810ad8f4f37dd9.
193,1.6.6,,1.6.6,
194,prepare 1.6.6,,prepare 1.6.6,
195,Ensure PopoverPanel can be used inside <transition> (#1653)," ensure there is an animatable root node  This is a bit sad, but it is how Vue works... We used to render just a simple PopoverPanel that resolved to let's say a <div>, that's all good. Because the native <transition> component requires that there is only 1 DOM child (regardless of the Vue ""tree""). This is the sad part, because we simplified focus trapping for the Popover by introducing sibling hidden buttons to capture focus instead of managing this ourselves. Since we can't just return multiple items we wrap them in a Fragment component. If you wrap items in a Fragment, then a lot of Vue's magic goes away (automatically adding class to the root node). Luckily, Vue has a solution for that, which is inheritAttrs: false and then manually spreading the attrs onto the correct element. This all works beautiful, but not for the <transition> component... so... let's move the focus trappable elements inside the actual Panel and update the logic slightly to go to the Next/Previous item instead of the First/Last because the First/Last will now be the actual focus guards.   update changelog   make TypeScript a bit happier   improve default slot in PopoverPanel ",Ensure PopoverPanel can be used inside  (#1653),"ensure there is an animatable root node This is a bit sad, but it is how Vue works... We used to render just a simple PopoverPanel that resolved to let's say a , that's all good. Because the native  component requires that there is only 1 DOM child (regardless of the Vue ""tree""). This is the sad part, because we simplified focus trapping for the Popover by introducing sibling hidden buttons to capture focus instead of managing this ourselves. Since we can't just return multiple items we wrap them in a Fragment component. If you wrap items in a Fragment, then a lot of Vue's magic goes away (automatically adding class to the root node). Luckily, Vue has a solution for that, which is inheritAttrs: false and then manually spreading the attrs onto the correct element. This all works beautiful, but not for the  component... so... let's move the focus trappable elements inside the actual Panel and update the logic slightly to go to the Next/Previous item instead of the First/Last because the First/Last will now be the actual focus guards. update changelog make TypeScript a bit happier improve default slot in PopoverPanel"
196,Properly merge incoming props with own props (#1651), sort props in error message  This will make the error message consistent regardless which props (and in what order) they are applied.   WIP   click() on a disabled element should no-op   incomingProps was already merged   cleanup tests a bit and make it consistent with the React tests   cleanup unused code   update changelog ,Properly merge incoming props with own props (#1651),sort props in error message This will make the error message consistent regardless which props (and in what order) they are applied. WIP click() on a disabled element should no-op incomingProps was already merged cleanup tests a bit and make it consistent with the React tests cleanup unused code update changelog
197,Fix bracket order of not variants (#1621),  fix order of brackets in selector   setup tests for @headlessui/tailwindcss   update changelog ,Fix bracket order of not variants (#1621),fix order of brackets in selector setup tests for @headlessui/tailwindcss update changelog
198,Ensure CMD+Backspace works in nullable mode for Combobox component (#1617)," ensure cmd+backspace works  The issue is that cmd+backspace technically already does work, but we only allowed it when the Combobox is in an open state. We can remove this check and apply the proper logic always.  update changelog",Ensure CMD+Backspace works in nullable mode for Combobox component (#1617),"ensure cmd+backspace works The issue is that cmd+backspace technically already does work, but we only allowed it when the Combobox is in an open state. We can remove this check and apply the proper logic always. update changelog"
199,Fix getting Vue dom elements (#1610),  Fix getting Vue dom elements   update changelog   Co-authored-by: Robin Malfait malfait.robin@gmail.com,Fix getting Vue dom elements (#1610),Fix getting Vue dom elements update changelog Co-authored-by: Robin Malfait malfait.robin@gmail.com
200,"Revert ""prepare 1.6.5""",This reverts commit c31136032b47567a2155be21af0e7701e0a1463d.,"Revert ""prepare 1.6.5""",This reverts commit c31136032b47567a2155be21af0e7701e0a1463d.
201,1.6.5,,1.6.5,
202,prepare 1.6.5,,prepare 1.6.5,
203,Fix missing aria-expanded for ComboboxInput component (#1605),  add test to verify Combobox.Input state   incorrect missing aria-expanded on ComboboxInput   update changelog ,Fix missing aria-expanded for ComboboxInput component (#1605),add test to verify Combobox.Input state incorrect missing aria-expanded on ComboboxInput update changelog
204,fix TypeScript issues (#1587),We had a bunch of unused imports sitting around,fix TypeScript issues (#1587),We had a bunch of unused imports sitting around
205,Fix scrolling issue in Tab component when using arrow keys (#1584),  prevent scrolling the page when using arrow keys in   update changelog   bump prettier   Does GitHub Actions have an incorrect cache somehow?  use Active LTS in CI,Fix scrolling issue in Tab component when using arrow keys (#1584),prevent scrolling the page when using arrow keys in update changelog bump prettier Does GitHub Actions have an incorrect cache somehow? use Active LTS in CI
206,Improve Combobox input cursor position (#1574),  fix(combobox): fix focus on option select   update changelog   Co-authored-by: Dan Roujinsky d.roujinsky@island.io,Improve Combobox input cursor position (#1574),fix(combobox): fix focus on option select update changelog Co-authored-by: Dan Roujinsky d.roujinsky@island.io
207,Only render the Dialog on the client (#1566),  only render the Dialog on the client   update changelog ,Only render the Dialog on the client (#1566),only render the Dialog on the client update changelog
208,Detect outside clicks from within <iframe> elements (#1552),  Refactor   Detect “outside clicks” inside <iframe> elements   Update changelog ,Detect outside clicks from within  elements (#1552),Refactor Detect “outside clicks” inside  elements Update changelog
209,Improve outside click of Dialog component (#1546),"  convert dialog in playground to use Dialog.Panel   convert tabs-in-dialog example to use Dialog.Panel   add scrollable dialog example to the playground   simplify outside click behaviour   Here is a little story. We used to use the click event listener on the window to try and detect whether we clicked outside of the main area we are working in. This all worked fine, until we got a bug report that it didn't work properly on Mobile, especially iOS. After a bit of debugging we switched this behaviour to use pointerdown instead of the click event listener. Worked great! Maybe... The reason the click didn't work was because of another bug fix. In React if you render a <form><Dialog></form> and your Dialog contains a button without a type, (or an input where you press enter) then the form would submit... even though we portalled the Dialog to a different location, but it bubbled the event up via the SyntethicEvent System. To fix this, we've added a ""simple"" onClick(e) { e.stopPropagation() } to make sure that click events didn't leak out. Alright no worries, but, now that we switched to pointerdown we got another bug report that it didn't work on older iOS devices. Fine, let's add a mousedown next to the pointerdown event. Now this works all great! Maybe... This doesn't work quite as we expected because it could happen that both events fire and then the onClose of the Dialog component would fire twice. In fact, there is an open issue about this: #1490 at the time of writing this commit message. We tried to only call the close function once by checking if those events happen within the same ""tick"", which is not always the case... Alright, let's ignore that issue for a second, there is another issue that popped up... If you have a Dialog that is scrollable (because it is greater than the current viewport) then a wild scrollbar appears (what a weird Pokémon). The moment you try to click the scrollbar or drag it the Dialog closes. What in the world...? Well... turns out that pointerdown gets fired if you happen to ""click"" (or touch) on the scrollbar. A click event does not get fired. No worries we can fix this! Maybe... (Narrator: ... nope ...) One thing we can try is to measure the scrollbar width, and if you happen to click near the edge then we ignore this click. You can think of it like let safeArea = viewportWidth - scrollBarWidth. Everything works great now! Maybe... Well, let me tell you about macOS and ""floating"" scrollbars... you can't measure those... AAAAAAAARGHHHH Alright, scratch that, let's add an invisible 20px gap all around the viewport without measuring as a safe area. Nobody will click in the 20px gap, right, right?! Everything works great now! Maybe... Mobile devices, yep, Dialogs are used there as well and usually there is not a lot of room around those Dialogs so you almost always hit the ""safe area"". Should we now try and detect the device people are using...? /me takes a deep breath... Inhales... Exhales... Alright, time to start thinking again... The outside click with a ""simple"" click worked on Menu and Listbox not on the Dialog so this should be enough right? WAIT A MINUTE Remember this piece of code from earlier: js onClick(event) {   event.stopPropagation() } The click event never ever reaches the window so we can't detect the click outside... Let's move that code to the Dialog.Panel instead of on the Dialog itself, this will make sure that we stop the click event from leaking if you happen to nest a Dialog in a form and have a submitable button/input in the Dialog.Panel. But if you click outside of the Dialog.Panel the ""click"" event will bubble to the window so that we can detect a click and check whether it was outside or not. Time to start cleaning:   - ☑️ Remove all the scrollbar measuring code...     - Closing works on mobile now, no more safe area hack   - ☑️ Remove the pointerdown & mousedown event     - Outside click doesn't fire twice anymore   - ☑️ Use a ""simple"" click event listener     - We can click the scrollbar and the browser ignores it for us All issues have been fixed! (Until the next one of course...)   ensure a Dialog.Panel exists   cleanup unnecessary code   use capture phase for outside click behaviour   further improve outside click   We added event.preventDefault() & event.defaultPrevented checks to make sure that we only handle 1 layer at a time. E.g.: ```js    Button ...   ``` If you open the Dialog, then open the Menu, pressing Escape will close the Menu but not the Dialog, pressing Escape again will close the Dialog. Now this is also applied to the outside click behaviour. If you open the Dialog, then open the Menu, clicking outside will close the Menu but not the Dialog, outside again will close the Dialog.   add explicit enabled value to the useOutsideClick hook   ensure outside click properly works with Poratl components   Usually this works out of the box, however our Portal components will render inside the Dialog component ""root"" to ensure that it is inside the non-inert tree and is inside the Dialog visually. This means that the Portal is not in a separate container and technically outside of the Dialog.Panel which means that it will close when you click on a non-interactive item inside that Portal... This fixes that and allows all Portal components.  update changelog",Improve outside click of Dialog component (#1546),"convert dialog in playground to use Dialog.Panel convert tabs-in-dialog example to use Dialog.Panel add scrollable dialog example to the playground simplify outside click behaviour Here is a little story. We used to use the click event listener on the window to try and detect whether we clicked outside of the main area we are working in. This all worked fine, until we got a bug report that it didn't work properly on Mobile, especially iOS. After a bit of debugging we switched this behaviour to use pointerdown instead of the click event listener. Worked great! Maybe... The reason the click didn't work was because of another bug fix. In React if you render a  and your Dialog contains a button without a type, (or an input where you press enter) then the form would submit... even though we portalled the Dialog to a different location, but it bubbled the event up via the SyntethicEvent System. To fix this, we've added a ""simple"" onClick(e) { e.stopPropagation() } to make sure that click events didn't leak out. Alright no worries, but, now that we switched to pointerdown we got another bug report that it didn't work on older iOS devices. Fine, let's add a mousedown next to the pointerdown event. Now this works all great! Maybe... This doesn't work quite as we expected because it could happen that both events fire and then the onClose of the Dialog component would fire twice. In fact, there is an open issue about this: #1490 at the time of writing this commit message. We tried to only call the close function once by checking if those events happen within the same ""tick"", which is not always the case... Alright, let's ignore that issue for a second, there is another issue that popped up... If you have a Dialog that is scrollable (because it is greater than the current viewport) then a wild scrollbar appears (what a weird Pokémon). The moment you try to click the scrollbar or drag it the Dialog closes. What in the world...? Well... turns out that pointerdown gets fired if you happen to ""click"" (or touch) on the scrollbar. A click event does not get fired. No worries we can fix this! Maybe... (Narrator: ... nope ...) One thing we can try is to measure the scrollbar width, and if you happen to click near the edge then we ignore this click. You can think of it like let safeArea = viewportWidth - scrollBarWidth. Everything works great now! Maybe... Well, let me tell you about macOS and ""floating"" scrollbars... you can't measure those... AAAAAAAARGHHHH Alright, scratch that, let's add an invisible 20px gap all around the viewport without measuring as a safe area. Nobody will click in the 20px gap, right, right?! Everything works great now! Maybe... Mobile devices, yep, Dialogs are used there as well and usually there is not a lot of room around those Dialogs so you almost always hit the ""safe area"". Should we now try and detect the device people are using...? /me takes a deep breath... Inhales... Exhales... Alright, time to start thinking again... The outside click with a ""simple"" click worked on Menu and Listbox not on the Dialog so this should be enough right? WAIT A MINUTE Remember this piece of code from earlier: js onClick(event) {   event.stopPropagation() } The click event never ever reaches the window so we can't detect the click outside... Let's move that code to the Dialog.Panel instead of on the Dialog itself, this will make sure that we stop the click event from leaking if you happen to nest a Dialog in a form and have a submitable button/input in the Dialog.Panel. But if you click outside of the Dialog.Panel the ""click"" event will bubble to the window so that we can detect a click and check whether it was outside or not. Time to start cleaning:   - ☑️ Remove all the scrollbar measuring code...     - Closing works on mobile now, no more safe area hack   - ☑️ Remove the pointerdown & mousedown event     - Outside click doesn't fire twice anymore   - ☑️ Use a ""simple"" click event listener     - We can click the scrollbar and the browser ignores it for us All issues have been fixed! (Until the next one of course...) ensure a Dialog.Panel exists cleanup unnecessary code use capture phase for outside click behaviour further improve outside click We added event.preventDefault() & event.defaultPrevented checks to make sure that we only handle 1 layer at a time. E.g.: ```js Button ... ``` If you open the Dialog, then open the Menu, pressing Escape will close the Menu but not the Dialog, pressing Escape again will close the Dialog. Now this is also applied to the outside click behaviour. If you open the Dialog, then open the Menu, clicking outside will close the Menu but not the Dialog, outside again will close the Dialog. add explicit enabled value to the useOutsideClick hook ensure outside click properly works with Poratl components Usually this works out of the box, however our Portal components will render inside the Dialog component ""root"" to ensure that it is inside the non-inert tree and is inside the Dialog visually. This means that the Portal is not in a separate container and technically outside of the Dialog.Panel which means that it will close when you click on a non-interactive item inside that Portal... This fixes that and allows all Portal components. update changelog"
210,"Support <slot> children when using as=""template"" (#1548)",  Extract renderTemplate logic   Flatten Fragments when rendering   Update changelog ,"Support  children when using as=""template"" (#1548)",Extract renderTemplate logic Flatten Fragments when rendering Update changelog
211,Fix incorrect transitionend/transitioncancel events for the Transition component (#1537)," fix incorrect transitionend/transitioncancel events  Due to bubbling, the Transition component also ""finished"" when you had children that uses transition-colors for example. This commit ensures that we only care about transition events related to the actual DOM node that we defined the transitions on...  update changelog",Fix incorrect transitionend/transitioncancel events for the Transition component (#1537),"fix incorrect transitionend/transitioncancel events Due to bubbling, the Transition component also ""finished"" when you had children that uses transition-colors for example. This commit ensures that we only care about transition events related to the actual DOM node that we defined the transitions on... update changelog"
212,"Revert ""prepare 1.6.4""",This reverts commit 842d07146ed4b6428ed7db090d10c481aa8670da.,"Revert ""prepare 1.6.4""",This reverts commit 842d07146ed4b6428ed7db090d10c481aa8670da.
213,1.6.4,,1.6.4,
214,prepare 1.6.4,,prepare 1.6.4,
215,Fix render prop data in RadioGroup component (#1522)," fix slot state of RadioGroup component  The useEvent is 1 tick too late (due to the update of the callback happening in useEffect). This isn't a problem for event listeners, but it is for functions that need to run ""now"". We can change the useLatestValue hook to do something like: ```diff   export function useLatestValue(value: T) {     let cache = useRef(value)  useIsoMorphicEffect(() => { cache.current = value }, [value])  cache.current = value return cache   } ```   But then we are mutating our refs in render which isn't ideal.   update changelog   add test to verify that the correct slot data is exposed ",Fix render prop data in RadioGroup component (#1522),"fix slot state of RadioGroup component The useEvent is 1 tick too late (due to the update of the callback happening in useEffect). This isn't a problem for event listeners, but it is for functions that need to run ""now"". We can change the useLatestValue hook to do something like: ```diff   export function useLatestValue(value: T) {     let cache = useRef(value) useIsoMorphicEffect(() => { cache.current = value }, [value]) cache.current = value return cache   } ``` But then we are mutating our refs in render which isn't ideal. update changelog add test to verify that the correct slot data is exposed"
216,update changelog,,update changelog,
217,fix transition enter bug (#1519),"We had an issue where an open Dialog got hidden by css didn't properly unmount because the Transition never ""finished"". We fixed this by checking if the node was hidden by using getBoundingClientRect. Today I learned that just reading those values (aka call node.getBoundingClientRect()) it for whatever reason completely stops the transition. This causes the enter transitions to completely stop working. Instead, we move this code so that we only check the existence of the Node when we try to transition out because this means that the Node is definitely there, just have to check its bounding rect.",fix transition enter bug (#1519),"We had an issue where an open Dialog got hidden by css didn't properly unmount because the Transition never ""finished"". We fixed this by checking if the node was hidden by using getBoundingClientRect. Today I learned that just reading those values (aka call node.getBoundingClientRect()) it for whatever reason completely stops the transition. This causes the enter transitions to completely stop working. Instead, we move this code so that we only check the existence of the Node when we try to transition out because this means that the Node is definitely there, just have to check its bounding rect."
218,Split CHANGELOG.md into file per package (#1516)," splitup CHANGELOG.md file  Scope each changelog per package  simplify CHANGELOG.md files  We don't need to scope them anymore, they are already scoped.",Split CHANGELOG.md into file per package (#1516),"splitup CHANGELOG.md file Scope each changelog per package simplify CHANGELOG.md files We don't need to scope them anymore, they are already scoped."
219,Fix event handlers with arity > 1 (#1515),  fix event handlers with arity > 1   update changelog ,Fix event handlers with arity > 1 (#1515),fix event handlers with arity > 1 update changelog
220,Remove leftover code in Combobox component (#1514)," remove leftover code  This code existed before we had the option to make the first option the ""active"" one. This also contains a bug in the React code where pressing ""ArrowDown"" in a closed Combobox opens the combobox and goes to the second item instead of the first option.  update changelog",Remove leftover code in Combobox component (#1514),"remove leftover code This code existed before we had the option to make the first option the ""active"" one. This also contains a bug in the React code where pressing ""ArrowDown"" in a closed Combobox opens the combobox and goes to the second item instead of the first option. update changelog"
221,Ensure Escape propagates correctly in Combobox component (#1511),  ensure Escape propagates correctly in Combobox component   update changelog ,Ensure Escape propagates correctly in Combobox component (#1511),ensure Escape propagates correctly in Combobox component update changelog
222,"Revert ""prepare 1.6.3""",This reverts commit 3aaf20b9acfd6f635b797d31cb41f4c16cb07d38.,"Revert ""prepare 1.6.3""",This reverts commit 3aaf20b9acfd6f635b797d31cb41f4c16cb07d38.
223,1.6.3,,1.6.3,
224,prepare 1.6.3,,prepare 1.6.3,
225,Ensure the Transition stops once DOM Nodes are hidden (#1500),  ensure that the transitions stops once the DOM Node is hidden   update changelog ,Ensure the Transition stops once DOM Nodes are hidden (#1500),ensure that the transitions stops once the DOM Node is hidden update changelog
226,0.1.0 - @headlessui/tailwindcss,,0.1.0 - @headlessui/tailwindcss,
227,update README,,update README,
228,update changelog,,update changelog,
229,Add @headlessui/tailwindcss plugin (#1487),"  add @headlessui/tailwindcss plugin   expose data-headlessui-state=""..."" data attribute   All components that expose boolean props in their render prop / v-slot will receive a data-headlessui-state=""..."" attribute. If it exposes boolean values but all are false, then there will be an empty data-headlessui-state="""". If the current component is rendering a Fragment then we don't expose those attributes.  use tailwindcss in playground-react and playground-vue  We were using the CDN, but now that we have the @headlessui/tailwindcss plugin, it's a bit easier to configure it natively and import the plugin.   ensure to build the @headlessui/tailwindcss package before starting the playground   refactor listbox example to use the @headlessui/tailwindcss plugin   update changelog   bump Tailwind CSS to latest insiders version   correctly generate types   type tailwind.config.js files for playgrounds   add todo for when :has() is available ",Add @headlessui/tailwindcss plugin (#1487),"add @headlessui/tailwindcss plugin expose data-headlessui-state=""..."" data attribute All components that expose boolean props in their render prop / v-slot will receive a data-headlessui-state=""..."" attribute. If it exposes boolean values but all are false, then there will be an empty data-headlessui-state="""". If the current component is rendering a Fragment then we don't expose those attributes. use tailwindcss in playground-react and playground-vue We were using the CDN, but now that we have the @headlessui/tailwindcss plugin, it's a bit easier to configure it natively and import the plugin. ensure to build the @headlessui/tailwindcss package before starting the playground refactor listbox example to use the @headlessui/tailwindcss plugin update changelog bump Tailwind CSS to latest insiders version correctly generate types type tailwind.config.js files for playgrounds add todo for when :has() is available"
230,cleanup unused import,,cleanup unused import,
231,small cleanup,"In the cleanup PR, we added the Data and Actions type, but we already had a Actions type so had to rename it to something. Chose Command but this is now inconsistent with the rest of the codebase. Instead, let's revert that change and use these shorthands:  Data -> _Data Actions -> _Actions Commands -> Actions CommandTypes -> ActionTypes  The _ prefix is a little bit strange, but it is a private type and not exposed so fine for now.",small cleanup,"In the cleanup PR, we added the Data and Actions type, but we already had a Actions type so had to rename it to something. Chose Command but this is now inconsistent with the rest of the codebase. Instead, let's revert that change and use these shorthands: Data -> _Data Actions -> _Actions Commands -> Actions CommandTypes -> ActionTypes The _ prefix is a little bit strange, but it is a private type and not exposed so fine for now."
232,Only render the FocusSentinel if required in the Tabs component (#1493), only render the FocusSentinel if required  Fixes: #1491  update changelog,Only render the FocusSentinel if required in the Tabs component (#1493),only render the FocusSentinel if required Fixes: #1491 update changelog
233,General/random internal cleanup (part 1) (#1484),  sort React imports   improve type signature of the useEvent hook   use more correct useIsoMorphicEffect check in useEvent   refactor useCallback to cleaner useEvent   convert const to let   Just for consistency..  cleanup Tabs code  Created explicit functions that can be called from child components instead of calling dispatch directly. Introduced a useData and useActions hook to make child components easier. The seperation of useData allows us to pass down props directly instead of going via the useReducer hook and dispatching actions to make values up to date.   cleanup Combobox code   cleanup RadioGroup code ,General/random internal cleanup (part 1) (#1484),sort React imports improve type signature of the useEvent hook use more correct useIsoMorphicEffect check in useEvent refactor useCallback to cleaner useEvent convert const to let Just for consistency.. cleanup Tabs code Created explicit functions that can be called from child components instead of calling dispatch directly. Introduced a useData and useActions hook to make child components easier. The seperation of useData allows us to pass down props directly instead of going via the useReducer hook and dispatching actions to make values up to date. cleanup Combobox code cleanup RadioGroup code
234,"Add by prop for Listbox, Combobox and RadioGroup (#1482)","  Add by prop for Listbox, Combobox and RadioGroup   update changelog ","Add by prop for Listbox, Combobox and RadioGroup (#1482)","Add by prop for Listbox, Combobox and RadioGroup update changelog"
235,Ensure the the <Popover.Panel focus> closes correctly (#1477),  ensure the the <Popover.Panel focus> closes correctly   update changelog ,Ensure the the  closes correctly (#1477),ensure the the  closes correctly update changelog
236,Allow to override the type on the Combobox.Input (#1476), allow to override the type on the Combobox.Input  This still defaults to text.  update changelog,Allow to override the type on the Combobox.Input (#1476),allow to override the type on the Combobox.Input This still defaults to text. update changelog
237,1.6.2 - @headlessui/vue,,1.6.2 - @headlessui/vue,
238,1.6.2 - @headlessui/react,,1.6.2 - @headlessui/react,
239,update changelog,,update changelog,
240,Ensure the ref is forwarded on the Transition.Child component (#1473),  use forwardRef on the Transition.Child component   update changelog ,Ensure the ref is forwarded on the Transition.Child component (#1473),use forwardRef on the Transition.Child component update changelog
241,Remove . from install instructions (#1468),Make this line just a little easier to copy paste.,Remove . from install instructions (#1468),Make this line just a little easier to copy paste.
242,Make the ref optional in the Popover component (#1465)," make the ref optional in the Popover component  We ""required"" the prop to calculate the ownerDocument. But if you don't provide a ref, then we will use the Popover.Button to calculate it. If that's not defined, then we can fallback to the default document.  update changelog",Make the ref optional in the Popover component (#1465),"make the ref optional in the Popover component We ""required"" the prop to calculate the ownerDocument. But if you don't provide a ref, then we will use the Popover.Button to calculate it. If that's not defined, then we can fallback to the default document. update changelog"
243,Don’t throw when SSR rendering internal portals in Vue (#1459),  Don’t throw when SSR rendering portals   Update changelog ,Don’t throw when SSR rendering internal portals in Vue (#1459),Don’t throw when SSR rendering portals Update changelog
244,ensure standalone imports and exports are rewritten as well (#1458),,ensure standalone imports and exports are rewritten as well (#1458),
245,"Improve ""Scroll lock"" scrollbar width for Dialog component (#1457)"," improve scroll lock, scrollbarWidth  The idea is as follow: If you currently have a scrollbar, and you open a Dialog then we enable a ""Scroll lock"" so that you can't scroll in the background behind the modal. We can achieve this by adding a overflow: hidden; to the html. The issue is that by doing this, we lose the scrollbar and therefore the page will jump to right because now there is a bit more room. To account for this, we set a padding-right on the html of the scrollbarWidth in pixels. This counteracts the visual jump you would see. The issue with this approach is that there could still be a scrollbar once we add the overflow: hidden. This can happen if you use new css features like the scrollbar-gutter: stable;. To take this into account, we will measure the scrollbar again after we set the overflow: hidden. Now we will only apply that counteracting offset if there would actually be a jump by measuring the before and after widths and applying the diff if there is one.  update changelog","Improve ""Scroll lock"" scrollbar width for Dialog component (#1457)","improve scroll lock, scrollbarWidth The idea is as follow: If you currently have a scrollbar, and you open a Dialog then we enable a ""Scroll lock"" so that you can't scroll in the background behind the modal. We can achieve this by adding a overflow: hidden; to the html. The issue is that by doing this, we lose the scrollbar and therefore the page will jump to right because now there is a bit more room. To account for this, we set a padding-right on the html of the scrollbarWidth in pixels. This counteracts the visual jump you would see. The issue with this approach is that there could still be a scrollbar once we add the overflow: hidden. This can happen if you use new css features like the scrollbar-gutter: stable;. To take this into account, we will measure the scrollbar again after we set the overflow: hidden. Now we will only apply that counteracting offset if there would actually be a jump by measuring the before and after widths and applying the diff if there is one. update changelog"
246,Fix playground warning about incorrectly loading stylesheets in Next.js (#1454),,Fix playground warning about incorrectly loading stylesheets in Next.js (#1454),
247,Ensure the Popover.Panel is clickable without closing the Popover (#1443),  ensure the Popover.Panel is clickable without closing   update changelog ,Ensure the Popover.Panel is clickable without closing the Popover (#1443),ensure the Popover.Panel is clickable without closing update changelog
248,Simplify Popover Tab logic by using sentinel nodes instead of keydown event interception (#1440), improve Popover keyboard usage  Use TabSentinel instead of intercepting the Tab keydown events.   use Buttons in Popover example   update changelog ,Simplify Popover Tab logic by using sentinel nodes instead of keydown event interception (#1440),improve Popover keyboard usage Use TabSentinel instead of intercepting the Tab keydown events. use Buttons in Popover example update changelog
249,Improve FocusTrap behaviour (#1432)," refactor VisuallyHidden to Hidden component  This new component will also make sure that it is visually hidden to sighted users. However, it contains a few more features that are going to be useful in other places as well. These features include:  Make visually hidden to sighted users (default) Hide from assistive technology via features={Features.Hidden}    (will add display: none;)  Hide from assistive technology but make the element focusable via    features={Features.Focusable} (will add aria-hidden=""true"")   add useEvent hook   This will behave the same (roughly) as the new to be released useEvent hook in React 18.X This hook allows you to have a stable function that can ""see"" the latest data it is using. We already had this concept using: js let handleX = useLatestValue(() => {   // ... }) But this returned a stable ref so you had to call handleX.current(). This new hook is a bit nicer to work with but doesn't change much in the end.  add useTabDirection hook  This keeps track of the direction people are tabbing in. This returns a ref so no re-renders happen because of this hook.  add useWatch hook  This is similar to the useEffect hook, but only executes if values are actually changing... 😒   add microTask util   refactor useFocusTrap hook to FocusTrap component   Using a component directly allows us to simplify the focus trap logic itself. Instead of intercepting the Tab keydown event and figuring out the correct element to focus, we will now add 2 ""guard"" buttons (hence why we require a component now). These buttons will receive focus and if they do, redirect the focus to the first/last element inside the focus trap. The sweet part is that all the tabs in between those buttons will now be handled natively by the browser. No need to find the first non disabled, non hidden with correct tabIndex element!  refactor the Dialog component to use the FocusTrap component  Also added a hidden button so that we know the correct ""main"" tree of the application. Before this we were assuming the previous active element which will still be correct in most cases but we don't have access to that anymore since the logic is encapsulated inside the FocusTrap component.  ensure <Portal /> properly cleans up  We make sure that the Portal is cleaning up its element properly. We also make sure to call the target.appendChild(element) conditionally because I ran into a super annoying bug where a focused element got blurred because I believe that this re-mounts the element instead of 'moving' it or just ignoring it, if it already is in the correct spot.  refactor: use useEvent instead of useLatestValue  Not really necessary, just cleaner.  update changelog",Improve FocusTrap behaviour (#1432),"refactor VisuallyHidden to Hidden component This new component will also make sure that it is visually hidden to sighted users. However, it contains a few more features that are going to be useful in other places as well. These features include: Make visually hidden to sighted users (default) Hide from assistive technology via features={Features.Hidden}    (will add display: none;) Hide from assistive technology but make the element focusable via    features={Features.Focusable} (will add aria-hidden=""true"") add useEvent hook This will behave the same (roughly) as the new to be released useEvent hook in React 18.X This hook allows you to have a stable function that can ""see"" the latest data it is using. We already had this concept using: js let handleX = useLatestValue(() => {   // ... }) But this returned a stable ref so you had to call handleX.current(). This new hook is a bit nicer to work with but doesn't change much in the end. add useTabDirection hook This keeps track of the direction people are tabbing in. This returns a ref so no re-renders happen because of this hook. add useWatch hook This is similar to the useEffect hook, but only executes if values are actually changing... 😒 add microTask util refactor useFocusTrap hook to FocusTrap component Using a component directly allows us to simplify the focus trap logic itself. Instead of intercepting the Tab keydown event and figuring out the correct element to focus, we will now add 2 ""guard"" buttons (hence why we require a component now). These buttons will receive focus and if they do, redirect the focus to the first/last element inside the focus trap. The sweet part is that all the tabs in between those buttons will now be handled natively by the browser. No need to find the first non disabled, non hidden with correct tabIndex element! refactor the Dialog component to use the FocusTrap component Also added a hidden button so that we know the correct ""main"" tree of the application. Before this we were assuming the previous active element which will still be correct in most cases but we don't have access to that anymore since the logic is encapsulated inside the FocusTrap component. ensure  properly cleans up We make sure that the Portal is cleaning up its element properly. We also make sure to call the target.appendChild(element) conditionally because I ran into a super annoying bug where a focused element got blurred because I believe that this re-mounts the element instead of 'moving' it or just ignoring it, if it already is in the correct spot. refactor: use useEvent instead of useLatestValue Not really necessary, just cleaner. update changelog"
250,Ignore Escape when event got prevented in Dialog component (#1424)," ignore Escape when event got prevented  Some external libraries only use event.preventDefault() and not event.stopPropagation(). This means that the Dialog can still receive an Escape keydown event which closes the Dialog. We can also think about the Escape behaviour inside the modal as the ""default behaviour"" once the Dialog is open. Therefore, we can also check the event.defaultPrevented and ignore this event when this is the case.  update changelog",Ignore Escape when event got prevented in Dialog component (#1424),"ignore Escape when event got prevented Some external libraries only use event.preventDefault() and not event.stopPropagation(). This means that the Dialog can still receive an Escape keydown event which closes the Dialog. We can also think about the Escape behaviour inside the modal as the ""default behaviour"" once the Dialog is open. Therefore, we can also check the event.defaultPrevented and ignore this event when this is the case. update changelog"
251,Fix closing of Popover.Panel in React 18 (#1409),  remove unnecessary SetPanel action   update changelog ,Fix closing of Popover.Panel in React 18 (#1409),remove unnecessary SetPanel action update changelog
252,Ensure DialogPanel exposes its ref (#1404),  ensure we expose the el and $el on DialogPanel   update changelog ,Ensure DialogPanel exposes its ref (#1404),ensure we expose the el and $el on DialogPanel update changelog
253,fix changelog diff links,,fix changelog diff links,
254,1.6.1 - @headlessui/vue,,1.6.1 - @headlessui/vue,
255,1.6.1 - @headlessui/react,,1.6.1 - @headlessui/react,
256,Fix enter transitions in Vue (#1395),  fix enter transitions in Vue   add example slide-over that shows the issue   update changelog   add Heroicons for playground ,Fix enter transitions in Vue (#1395),fix enter transitions in Vue add example slide-over that shows the issue update changelog add Heroicons for playground
257,temporary ignore flaky tests,,temporary ignore flaky tests,
258,Fix hydration issue with Tab component (#1393),  fix hydration issues with Tabs component   update changelog ,Fix hydration issue with Tab component (#1393),fix hydration issues with Tabs component update changelog
259,"Manually passthrough attrs for Combobox, Listbox and TabsGroup component (#1372)"," manually pass through attrs  Due to the return of the Fragment (for form compatibility) the attributes will now be pass onto this Fragment instead of the underlying DOM node. To fix this, we disable the inheritAttrs magic, and passthrough the attributes to the correct component.  update changelog","Manually passthrough attrs for Combobox, Listbox and TabsGroup component (#1372)","manually pass through attrs Due to the return of the Fragment (for form compatibility) the attributes will now be pass onto this Fragment instead of the underlying DOM node. To fix this, we disable the inheritAttrs magic, and passthrough the attributes to the correct component. update changelog"
260,update changelog,,update changelog,
261,Improvements to changelog,,Improvements to changelog,
262,1.6.0,,1.6.0,
263,update changelog,,update changelog,
264,General cleanup of README files (#1361),"  cleanup README files   ignore flakey tests for now   There are a handful of tests that are pretty flakey and fail every once in a while on CI, I don't want to remove them yet, but rather ignore them for now. I am going to experiment with using Playwright/Puppeteer to use a real browser instead.",General cleanup of README files (#1361),"cleanup README files ignore flakey tests for now There are a handful of tests that are pretty flakey and fail every once in a while on CI, I don't want to remove them yet, but rather ignore them for now. I am going to experiment with using Playwright/Puppeteer to use a real browser instead."
265,Prefer incoming open prop over OpenClosed state (#1360),  prefer incoming open prop over OpenClosed state   update changelog ,Prefer incoming open prop over OpenClosed state (#1360),prefer incoming open prop over OpenClosed state update changelog
266,update changelog,,update changelog,
267,fix nullable prop for Vue,,fix nullable prop for Vue,
268,Add explicit multiple prop (#1355)," add explicit multiple prop to the Combobox  This allows you to set the value to a tuple in single-value mode, which was not possible before the multiple prop was introduced, because then it resulted in multi-value mode instead of single-value mode.  add explicit multiple prop to the Listbox  This allows you to set the value to a tuple in single-value mode, which was not possible before the multiple prop was introduced, because then it resulted in multi-value mode instead of single-value mode.   update changelog   update playground to use multiple prop ",Add explicit multiple prop (#1355),"add explicit multiple prop to the Combobox This allows you to set the value to a tuple in single-value mode, which was not possible before the multiple prop was introduced, because then it resulted in multi-value mode instead of single-value mode. add explicit multiple prop to the Listbox This allows you to set the value to a tuple in single-value mode, which was not possible before the multiple prop was introduced, because then it resulted in multi-value mode instead of single-value mode. update changelog update playground to use multiple prop"
269,use older syntax instead of .at(),Fixes: #1344,use older syntax instead of .at(),Fixes: #1344
270,Add Dialog.Backdrop and Dialog.Panel components (#1333),  implement Dialog.Backdrop and Dialog.Panel   cleanup TypeScript warnings   update changelog ,Add Dialog.Backdrop and Dialog.Panel components (#1333),implement Dialog.Backdrop and Dialog.Panel cleanup TypeScript warnings update changelog
271,add React 18 compatibility (#1326),"  bump dev dependencies to React 18   setup Jest to include IS_REACT_ACT_ENVIRONMENT   prefer useId from React 18 if it exists   In React 16 & 17, where useId doesn't exist, we will fallback to our implementation we have been using up until now. The useId exposed by React 18, ensures stable references even in SSR environments.  update expected events  React 18 now uses the proper events: - blur -> focusout - focus -> focusin  ensure to wait a bit longer  This is a bit unfortunate, but since React 18 now does an extra unmount/remount in StrictMode to ensure that your code is ConcurrentMode ready, it takes a bit longer to settle what the DOM sees. That said, this is a temporary ""hack"". We are going to experiment with using tools like Puppeteer/Playwright to run our tests in an actual browser instead to eliminate all the weird details that we have to keep in mind.   prefer .focus() over fireEvent.focus(el)   abstract microTask polyfill code   prefer our focus(el) function over el.focus()   Internally we would still use el.focus(), but this allows us to have more control over that focus function.   add React 18 to the React Playground   improve hooks for React 18   Improving the cleanup of useEffect hooks   useIsoMorphicEffect instead of normal useEffect, so that we can use   useLayoutEffect to be a bit quicker.   improve disposables   This allows us to add event listeners on a node, and get automatic   cleanup once dispose gets called.   We also return all the d.add calls, so that we can cleanup specific   parts only instead of everything or nothing.   reimplement the Transition component to be React 18 ready   wait an additional frame for everything to settle   update playground examples   suppressConsoleLogs for RadioGroup components   update changelog   keep the to classes for a smoother transition   In the next transition we will remove all classes provided and re-add the once we need.  Some extra special thanks:  Thanks @silvenon for your initial work on the transition events in #926 Thanks @thecrypticace for doing late-night debugging sessions  Co-authored-by: =?UTF-8?q?Matija=20Marohni=C4=87?= matija.marohnic@gmail.com Co-authored-by: Jordan Pittman jordan@cryptica.me",add React 18 compatibility (#1326),"bump dev dependencies to React 18 setup Jest to include IS_REACT_ACT_ENVIRONMENT prefer useId from React 18 if it exists In React 16 & 17, where useId doesn't exist, we will fallback to our implementation we have been using up until now. The useId exposed by React 18, ensures stable references even in SSR environments. update expected events React 18 now uses the proper events: - blur -> focusout - focus -> focusin ensure to wait a bit longer This is a bit unfortunate, but since React 18 now does an extra unmount/remount in StrictMode to ensure that your code is ConcurrentMode ready, it takes a bit longer to settle what the DOM sees. That said, this is a temporary ""hack"". We are going to experiment with using tools like Puppeteer/Playwright to run our tests in an actual browser instead to eliminate all the weird details that we have to keep in mind. prefer .focus() over fireEvent.focus(el) abstract microTask polyfill code prefer our focus(el) function over el.focus() Internally we would still use el.focus(), but this allows us to have more control over that focus function. add React 18 to the React Playground improve hooks for React 18 Improving the cleanup of useEffect hooks useIsoMorphicEffect instead of normal useEffect, so that we can use   useLayoutEffect to be a bit quicker. improve disposables This allows us to add event listeners on a node, and get automatic   cleanup once dispose gets called. We also return all the d.add calls, so that we can cleanup specific   parts only instead of everything or nothing. reimplement the Transition component to be React 18 ready wait an additional frame for everything to settle update playground examples suppressConsoleLogs for RadioGroup components update changelog keep the to classes for a smoother transition In the next transition we will remove all classes provided and re-add the once we need. Some extra special thanks: Thanks @silvenon for your initial work on the transition events in #926 Thanks @thecrypticace for doing late-night debugging sessions Co-authored-by: =?UTF-8?q?Matija=20Marohni=C4=87?= matija.marohnic@gmail.com Co-authored-by: Jordan Pittman jordan@cryptica.me"
272,Implement nullable mode on Combobox in single value mode (#1295),"  implement backspace behaviour in tests   add Delete Key   implement nullable mode on Combobox in single value mode   If you pass a nullable prop to the Combobox, then it's possible to unset the Combobox value by setting it to null. This is triggered by removing all text from the input which will reset the value itself as well.  update changelog",Implement nullable mode on Combobox in single value mode (#1295),"implement backspace behaviour in tests add Delete Key implement nullable mode on Combobox in single value mode If you pass a nullable prop to the Combobox, then it's possible to unset the Combobox value by setting it to null. This is triggered by removing all text from the input which will reset the value itself as well. update changelog"
273,"Allow Enter for form submit in RadioGroup, Switch and Combobox improvements (#1285)","  improve rendering of hidden form fields   add attemptSubmit helper   This will allow us to try and submit a form based on any element you pass it. It will try and lookup the current form and if it is submittable it will attempt to submit it. Instead of submitting the form directly, we try to follow the native browser support where it looks for the first input[type=submit], input[type=image], button or button[type=submit], then it clicks it. This allows you to disable your submit button, or have an onClick that does an event.preventDefault() just like the native form in a browser would do.  ensure we can submit a form from a closed Combobox  When the Combobox is closed, then the Enter keydown event will be ignored and thus not use event.preventDefault(). With recent changes where we always have an active option, it means that you will always be able to select an option. If we have no option at all (some edge case) or when the combobox is closed, then the Enter keydown event will just bubble, allowing you to submit a form. Fixes: #1282 This is a continuation of a PR (#1176) provided by Alexander, so wanted to include them as a co-author because of their initial work. Co-authored-by: Alexander Lyon arlyon@me.com   ensure we can submit a form from a RadioGroup   ensure we can submit a form from a Switch   simplify / refactor form playground example   update changelog   Co-authored-by: Alexander Lyon arlyon@me.com","Allow Enter for form submit in RadioGroup, Switch and Combobox improvements (#1285)","improve rendering of hidden form fields add attemptSubmit helper This will allow us to try and submit a form based on any element you pass it. It will try and lookup the current form and if it is submittable it will attempt to submit it. Instead of submitting the form directly, we try to follow the native browser support where it looks for the first input[type=submit], input[type=image], button or button[type=submit], then it clicks it. This allows you to disable your submit button, or have an onClick that does an event.preventDefault() just like the native form in a browser would do. ensure we can submit a form from a closed Combobox When the Combobox is closed, then the Enter keydown event will be ignored and thus not use event.preventDefault(). With recent changes where we always have an active option, it means that you will always be able to select an option. If we have no option at all (some edge case) or when the combobox is closed, then the Enter keydown event will just bubble, allowing you to submit a form. Fixes: #1282 This is a continuation of a PR (#1176) provided by Alexander, so wanted to include them as a co-author because of their initial work. Co-authored-by: Alexander Lyon arlyon@me.com ensure we can submit a form from a RadioGroup ensure we can submit a form from a Switch simplify / refactor form playground example update changelog Co-authored-by: Alexander Lyon arlyon@me.com"
274,Fix required double ArrowDown requirement (#1281)," fix double arrow down requirement  If the activeOptionIndex is set to null, then we default to the very first non-disabled option. This data is not stored in state because if you as the user go to a specific option, then start searching then we will maintain the active option. This means that we have to update the activeOptionIndex when options are moving around. While making the first option the active one, we can't store that in state directly otherwise the very first option becomes the active one. If we then inject combobox options before the current one then all of a sudden your active option would jump around a bit. We don't want this jumping to happen, we want the very first option to be the one that's active no matter which option it is. Since this is not stored in state, our keydown handler was a bit borked. Internally it thinks we are still at activeOptionIndex === null therefore pressing arrow down would move us to activeOptionIndex === 0. To go to the second option, we can press down again which would move us to activeOptionIndex === 1. The only issue is that visually we were already at 0. This fixes that by making sure that if we have activeOptionIndex === null that we fallback to the very first non disabled option before we execute the goToOption() code. ### Before: Open combobox, activeOptionIndex === null | Combobox                | | ----------------------- | | Option A (active) | | Option B                | | Option C                | Arrow Down, activeOptionIndex === 0 | Combobox                | | ----------------------- | | Option A (active) | | Option B                | | Option C                | Arrow Down, activeOptionIndex === 1 | Combobox                | | ----------------------- | | Option A                | | Option B (active) | | Option C                | ### After: Open combobox, activeOptionIndex === null | Combobox                | | ----------------------- | | Option A (active) | | Option B                | | Option C                | Arrow Down, activeOptionIndex === 1 | Combobox                | | ----------------------- | | Option A                | | Option B (active) | | Option C                |  update changelog",Fix required double ArrowDown requirement (#1281),"fix double arrow down requirement If the activeOptionIndex is set to null, then we default to the very first non-disabled option. This data is not stored in state because if you as the user go to a specific option, then start searching then we will maintain the active option. This means that we have to update the activeOptionIndex when options are moving around. While making the first option the active one, we can't store that in state directly otherwise the very first option becomes the active one. If we then inject combobox options before the current one then all of a sudden your active option would jump around a bit. We don't want this jumping to happen, we want the very first option to be the one that's active no matter which option it is. Since this is not stored in state, our keydown handler was a bit borked. Internally it thinks we are still at activeOptionIndex === null therefore pressing arrow down would move us to activeOptionIndex === 0. To go to the second option, we can press down again which would move us to activeOptionIndex === 1. The only issue is that visually we were already at 0. This fixes that by making sure that if we have activeOptionIndex === null that we fallback to the very first non disabled option before we execute the goToOption() code. Before: Open combobox, activeOptionIndex === null | Combobox                | | ----------------------- | | Option A (active) | | Option B                | | Option C                | Arrow Down, activeOptionIndex === 0 | Combobox                | | ----------------------- | | Option A (active) | | Option B                | | Option C                | Arrow Down, activeOptionIndex === 1 | Combobox                | | ----------------------- | | Option A                | | Option B (active) | | Option C                | After: Open combobox, activeOptionIndex === null | Combobox                | | ----------------------- | | Option A (active) | | Option B                | | Option C                | Arrow Down, activeOptionIndex === 1 | Combobox                | | ----------------------- | | Option A                | | Option B (active) | | Option C                | update changelog"
275,Ensure that there is always an active option in the Combobox (#1279)," ensure that the first option is always active  This will ensure that the first non-disabled option is the active one if no other active options exist. This means that any time you search for something that the first result is the active one and you can just press Enter to activate the option. However, there are a few rules that we have to take into account: - If you just open the Combobox, and there is a selected   Combobox.Option, then we can't make the first option the active one.   The first selected Combobox.Option has precedence over this one. This   is important and rather tricky because Combobox.Option's register   themselves at some point (later) in time. - If you already have an active option, then that option should stay   active. If it changes position, then the activeOptionIndex is adjusted   to account for that. - If you ""mouse leave"" an option, then no option should be active. It   will be re-enabled the moment you start typing OR if you re-open the   Combobox. Otherwise, it can happen that you are at the bottom of the   list, mouse leave, and we scroll all the way back up to make the first   item the active one which is not good for UX reasons.   filter list based on query in the playground   update changelog ",Ensure that there is always an active option in the Combobox (#1279),"ensure that the first option is always active This will ensure that the first non-disabled option is the active one if no other active options exist. This means that any time you search for something that the first result is the active one and you can just press Enter to activate the option. However, there are a few rules that we have to take into account: - If you just open the Combobox, and there is a selected   Combobox.Option, then we can't make the first option the active one.   The first selected Combobox.Option has precedence over this one. This   is important and rather tricky because Combobox.Option's register   themselves at some point (later) in time. - If you already have an active option, then that option should stay   active. If it changes position, then the activeOptionIndex is adjusted   to account for that. - If you ""mouse leave"" an option, then no option should be active. It   will be re-enabled the moment you start typing OR if you re-open the   Combobox. Otherwise, it can happen that you are at the bottom of the   list, mouse leave, and we scroll all the way back up to make the first   item the active one which is not good for UX reasons. filter list based on query in the playground update changelog"
276,Mimic browser select on focus when navigating via Tab (#1272), mimic browser select on focus  When calling focusIn if the next node is selectable select all the text.   refactor browser select behaviour for React and Vue   update changelog   Co-authored-by: Robin Malfait malfait.robin@gmail.com,Mimic browser select on focus when navigating via Tab (#1272),mimic browser select on focus When calling focusIn if the next node is selectable select all the text. refactor browser select behaviour for React and Vue update changelog Co-authored-by: Robin Malfait malfait.robin@gmail.com
277,Resolve initialFocusRef correctly (#1276)," resolve initialFocusRef correctly  If you are passing a Ref to a component, you don't get the underlying DOM node even if you put it on the element manually. The ref will be a ref to the component. This means that the initialFocusRef can be a DOM element or a Vue component instance. Resolving it guarantees us to resolve to an HTMLElement or null but not a component.  update changelog",Resolve initialFocusRef correctly (#1276),"resolve initialFocusRef correctly If you are passing a Ref to a component, you don't get the underlying DOM node even if you put it on the element manually. The ref will be a ref to the component. This means that the initialFocusRef can be a DOM element or a Vue component instance. Resolving it guarantees us to resolve to an HTMLElement or null but not a component. update changelog"
278,update changelog,,update changelog,
279,Fix incorrect closing while interacting with third party libraries in Dialog component (#1268),  ensure to keep the Dialog open when clicking on 3rd party elements   update playground with a Flatpickr example   update changelog ,Fix incorrect closing while interacting with third party libraries in Dialog component (#1268),ensure to keep the Dialog open when clicking on 3rd party elements update playground with a Flatpickr example update changelog
280,Properly merge incoming props (#1265)," rename inconsistent passThroughProps and passthroughProps to more concise incomingProps  This is going to make a bit more sense in the next commits of this branch, hold on!  split props into propsWeControl and propsTheyControl  This will allow us to merge the props with a bit more control. Instead of overriding every prop from the user' props with our props, we can now merge event listeners.   update render API to accept propsWeControl and propsTheyControl   improve the merge logic   This will essentially do the exact same thing we were doing before: js let props = { ...propsTheyControl, ...propsWeControl } But instead of overriding everything, we will merge the event listener related props like onClick, onKeyDown, ...   fix typo in tests   simplify naming   Rename propsWeControl to ourProps   Rename propsTheyControl to theirProps   update changelog ",Properly merge incoming props (#1265),"rename inconsistent passThroughProps and passthroughProps to more concise incomingProps This is going to make a bit more sense in the next commits of this branch, hold on! split props into propsWeControl and propsTheyControl This will allow us to merge the props with a bit more control. Instead of overriding every prop from the user' props with our props, we can now merge event listeners. update render API to accept propsWeControl and propsTheyControl improve the merge logic This will essentially do the exact same thing we were doing before: js let props = { ...propsTheyControl, ...propsWeControl } But instead of overriding everything, we will merge the event listener related props like onClick, onKeyDown, ... fix typo in tests simplify naming Rename propsWeControl to ourProps Rename propsTheyControl to theirProps update changelog"
281,Fix incorrect active option in the Listbox/Combobox component (#1264),"  update tests to expose bug in React implementation   fix incorrect active state on mouseLeave   The React code had a bug in the Listbox and Combobox components where it incorrectly made the first selected value the active value. The first selected option should be the active option when you open the listbox. However when you already had the component in an open state, hovered over a non-selected item and them left the option by moving it to the body then the first selected option became the active one again. This made sense because we used a useEffect in each option to make it the active one if it was also selected. Since every component re-renders, code got called and the bug arises. Now, instead we moved the logic to make it the active option to the reducer logic. We will check it when we register an option and doesn't have an active option index yet or when we open the Listbox/Combobox. This should also solve the strange scrolling behaviour where the options scroll up if you have more options than you display.  update changelog",Fix incorrect active option in the Listbox/Combobox component (#1264),"update tests to expose bug in React implementation fix incorrect active state on mouseLeave The React code had a bug in the Listbox and Combobox components where it incorrectly made the first selected value the active value. The first selected option should be the active option when you open the listbox. However when you already had the component in an open state, hovered over a non-selected item and them left the option by moving it to the body then the first selected option became the active one again. This made sense because we used a useEffect in each option to make it the active one if it was also selected. Since every component re-renders, code got called and the bug arises. Now, instead we moved the logic to make it the active option to the reducer logic. We will check it when we register an option and doesn't have an active option index yet or when we open the Listbox/Combobox. This should also solve the strange scrolling behaviour where the options scroll up if you have more options than you display. update changelog"
282,Stop propagation on the Popover Button (#1263), stop propagation on Popover Button  This is only done on buttons that are not inside the Popover Panel.   update changelog   trigger CI ,Stop propagation on the Popover Button (#1263),stop propagation on Popover Button This is only done on buttons that are not inside the Popover Panel. update changelog trigger CI
283,add tests to prove guarding against infinite loops is important (#1253),,add tests to prove guarding against infinite loops is important (#1253),
284,Fix Tree-shaking support (#1247)," improve Tree Shaking in ESM  Instead of bundling everything into a single ESM file, we generate every single file as ESM. This is what we did in 1.4.x as well. I would expect if your library had a single ESM file and you only used 1 function that the application you use it in correctly does the tree-shakign for you. Apparantly a lot of applications are not properly setup for this, so let's create multiple files instead.  update changelog",Fix Tree-shaking support (#1247),"improve Tree Shaking in ESM Instead of bundling everything into a single ESM file, we generate every single file as ESM. This is what we did in 1.4.x as well. I would expect if your library had a single ESM file and you only used 1 function that the application you use it in correctly does the tree-shakign for you. Apparantly a lot of applications are not properly setup for this, so let's create multiple files instead. update changelog"
285,Improve Combobox Input value (#1248),  improve Combobox Input value   update changelog ,Improve Combobox Input value (#1248),improve Combobox Input value update changelog
286,Add multi value support for Listbox & Combobox (#1243),"  First attempt at a multi-listbox   implement multiple mode on Listbox   add multiple Listbox example to playground   implement multiple mode on Combobox   make sure groupContext is not undefined or null   On vercel, getting a strange issue like TypeError: undefined is not an object (evaluating 'r.resolveTarget') which doesn't happen locally or once published. Would expect it to be null since we default to null. Hopefully this fixes things.   bump all the dependencies   make sure that @types/react use set to the correct version   @types/react-dom hardcoded the @types/react to version 16.14.21 instead of using the latest 16.14.24 resulting in type mismatches. cries in inconsistency   update changelog   add multiple Combobox example to playground   refactor Combobox, use actions   use combobox data   This is a first step in refactoring everything where we use dedicated actions and data instead of accessing the reducer state directly. It also allows us to get rid of mutations in render where we updated some values in render directly which is not ideal. Co-authored-by: pvanliefland pierre.vanliefland@gmail.com",Add multi value support for Listbox & Combobox (#1243),"First attempt at a multi-listbox implement multiple mode on Listbox add multiple Listbox example to playground implement multiple mode on Combobox make sure groupContext is not undefined or null On vercel, getting a strange issue like TypeError: undefined is not an object (evaluating 'r.resolveTarget') which doesn't happen locally or once published. Would expect it to be null since we default to null. Hopefully this fixes things. bump all the dependencies make sure that @types/react use set to the correct version @types/react-dom hardcoded the @types/react to version 16.14.21 instead of using the latest 16.14.24 resulting in type mismatches. cries in inconsistency update changelog add multiple Combobox example to playground refactor Combobox, use actions use combobox data This is a first step in refactoring everything where we use dedicated actions and data instead of accessing the reducer state directly. It also allows us to get rid of mutations in render where we updated some values in render directly which is not ideal. Co-authored-by: pvanliefland pierre.vanliefland@gmail.com"
287,Fix typo in .github/CONTRIBUTING.md (#1232),  Fix typo in .github/CONTRIBUTING.md   trigger builds   Co-authored-by: Robin Malfait malfait.robin@gmail.com,Fix typo in .github/CONTRIBUTING.md (#1232),Fix typo in .github/CONTRIBUTING.md trigger builds Co-authored-by: Robin Malfait malfait.robin@gmail.com
288,"Ensure focus trap, Tabs and Dialog play well together (#1231)"," add internal FocusSentinel component  This component will allow you to catch the focus and forward it to a new element. The catch is that it will retry to do that because sometimes components won't be available yet. E.g.: We want to focus the first Tab component if it is rendered inside the Dialog. However, a Tab will register itself in the next tick, triggering a re-render and only then will it be selected. This is a bit too late for the FocusTrap component. The FocusSentinel should fix this by catching the focus, and forwarding it to the correct component. Once that is done, it will remove itself from the DOM tree so that you can't ever focus that element anymore. This should fix potential <tab> and <shift+tab> behaviour.   find the selectedIndex asap   use the FocusSentinel and forward it to the correct Tab   add example Tab in Dialog example   suppress console warnings   Because we are firing setState calls within the component, React is yelling at us for not using act(() => { ... }). Welp, not going to add those calls inside the component just for tests...  update changelog","Ensure focus trap, Tabs and Dialog play well together (#1231)","add internal FocusSentinel component This component will allow you to catch the focus and forward it to a new element. The catch is that it will retry to do that because sometimes components won't be available yet. E.g.: We want to focus the first Tab component if it is rendered inside the Dialog. However, a Tab will register itself in the next tick, triggering a re-render and only then will it be selected. This is a bit too late for the FocusTrap component. The FocusSentinel should fix this by catching the focus, and forwarding it to the correct component. Once that is done, it will remove itself from the DOM tree so that you can't ever focus that element anymore. This should fix potential  and  behaviour. find the selectedIndex asap use the FocusSentinel and forward it to the correct Tab add example Tab in Dialog example suppress console warnings Because we are firing setState calls within the component, React is yelling at us for not using act(() => { ... }). Welp, not going to add those calls inside the component just for tests... update changelog"
289,Re-expose el (#1230)," re-expose el  We used to expose a custom el when we used a setup() and render() function. But due to some refactors we got now only have a setup() and no more el. This causes some problems if people relied on the exposed el. In this PR will make sure to re-expose the el that we used to expose. The only issue is, now that we manually expose a list, we have to re-expose the $el internal as well.  update changelog",Re-expose el (#1230),"re-expose el We used to expose a custom el when we used a setup() and render() function. But due to some refactors we got now only have a setup() and no more el. This causes some problems if people relied on the exposed el. In this PR will make sure to re-expose the el that we used to expose. The only issue is, now that we manually expose a list, we have to re-expose the $el internal as well. update changelog"
290,Use ownerDocument instead of document (#1158), use ownerDocument instead of document  This should ensure that in iframes and new windows the correct document is being used.  update changelog,Use ownerDocument instead of document (#1158),use ownerDocument instead of document This should ensure that in iframes and new windows the correct document is being used. update changelog
291,Don’t drop initial character when searching in Combobox (#1223),  Don’t drop initial character when searching in Combobox   Update changelog ,Don’t drop initial character when searching in Combobox (#1223),Don’t drop initial character when searching in Combobox Update changelog
292,Improve some internal code (#1221)," remove raw document.getElementById calls  When we introduced the forwardRef for all components, we also made sure that internal refs were used to keep track of the actual DOM node. This code prefers the internalXXRef refs in favor of the document.getElementById calls. This is way more React-ish, and also fixes a few issues:  Potential performance improvements (no need to re-query the DOM, since   we already have a reference to the DOM node). Note: this is a guess,   I didn't measure this.  It could be that the element is rendered in another document, the   correct would involve something like   someDOMNode.ownerDocument.getElementById(...) but that should not be   necessary anymore now.   make Disclosure implementation between React & Vue consistent   use a similar convention for DOM refs to other components   update changelog ",Improve some internal code (#1221),"remove raw document.getElementById calls When we introduced the forwardRef for all components, we also made sure that internal refs were used to keep track of the actual DOM node. This code prefers the internalXXRef refs in favor of the document.getElementById calls. This is way more React-ish, and also fixes a few issues: Potential performance improvements (no need to re-query the DOM, since   we already have a reference to the DOM node). Note: this is a guess,   I didn't measure this. It could be that the element is rendered in another document, the   correct would involve something like   someDOMNode.ownerDocument.getElementById(...) but that should not be   necessary anymore now. make Disclosure implementation between React & Vue consistent use a similar convention for DOM refs to other components update changelog"
293,Remove focus() from Listbox Option (#1218)," cleanup auto-scrolling  We keep the actual container focused, so we don't require the invidiual option to be focused as well. We do want to scroll it into view but that's part of another piece of code. Also cleaned up some manual document.querySelector calls now that we keep track of a ref.  update changelog",Remove focus() from Listbox Option (#1218),"cleanup auto-scrolling We keep the actual container focused, so we don't require the invidiual option to be focused as well. We do want to scroll it into view but that's part of another piece of code. Also cleaned up some manual document.querySelector calls now that we keep track of a ref. update changelog"
294,Add <form> compatibility (#1214)," implement objetToFormEntries functionality  If we are working with more complex data structures then we have to encode those data structures into a syntax that the HTML can understand. This means that we have to use <input type=""hidden"" name=""..."" value=""...""> syntax. To convert a simple array we can use the following syntax: js // Assuming we have a `name` of `person` let input = ['Alice', 'Bob', 'Charlie'] Results in: html <input type=""hidden"" name=""person[]"" value=""Alice"" /> <input type=""hidden"" name=""person[]"" value=""Bob"" /> <input type=""hidden"" name=""person[]"" value=""Charlie"" /> Note: the additional [] in the name attribute.  A more complex object (even deeply nested) can be encoded like this: js // Assuming we have a `name` of `person` let input = {   id: 1,   name: {     first: 'Jane',     last: 'Doe'   } } Results in: html <input type=""hidden"" name=""person[id]"" value=""1"" /> <input type=""hidden"" name=""person[name][first]"" value=""Jane"" /> <input type=""hidden"" name=""person[name][last]"" value=""Doe"" />   implement VisuallyHidden component   implement and export some extra helper utilities   implement form element for Switch   implement form element for Combobox   implement form element for RadioGroup   implement form element for Listbox   add combined forms example to the playground   update changelog   enable support for iterators   ensure to compile dom iterables   remove unused imports ",Add  compatibility (#1214),"implement objetToFormEntries functionality If we are working with more complex data structures then we have to encode those data structures into a syntax that the HTML can understand. This means that we have to use  syntax. To convert a simple array we can use the following syntax: js // Assuming we have a module of module let input = ['Alice', 'Bob', 'Charlie'] Results in: html    Note: the additional [] in the name attribute. A more complex object (even deeply nested) can be encoded like this: js // Assuming we have a module of module let input = {   id: 1,   name: {     first: 'Jane',     last: 'Doe'   } } Results in: html    implement VisuallyHidden component implement and export some extra helper utilities implement form element for Switch implement form element for Combobox implement form element for RadioGroup implement form element for Listbox add combined forms example to the playground update changelog enable support for iterators ensure to compile dom iterables remove unused imports"
295,"Ignore ""outside click"" on removed elements (#1193)"," ignore ""outside click"" on removed elements  Co-authored-by: Colin King me@colinking.co  update changelog  Co-authored-by: Colin King me@colinking.co","Ignore ""outside click"" on removed elements (#1193)","ignore ""outside click"" on removed elements Co-authored-by: Colin King me@colinking.co update changelog Co-authored-by: Colin King me@colinking.co"
296,only activate the Tab on mouseup (#1192),,only activate the Tab on mouseup (#1192),
297,Fix Dialog cycling (#553),  add tests to verify that tabbing around when using initialFocus works   add nesting example to playground-vue   fix nested dialog and initialFocus cycling   make React dialog consistent   Disable FocusLock on leaf Dialog's   update changelog ,Fix Dialog cycling (#553),add tests to verify that tabbing around when using initialFocus works add nesting example to playground-vue fix nested dialog and initialFocus cycling make React dialog consistent Disable FocusLock on leaf Dialog's update changelog
298,Fix re-focusing element after close (#1186)," fix restoreElement logic  The code for React already worked, let's update the Vue code to make it similar which properly restores focus.  update changelog",Fix re-focusing element after close (#1186),"fix restoreElement logic The code for React already worked, let's update the Vue code to make it similar which properly restores focus. update changelog"
299,"Adjust active {item,option} index (#1184)"," adjust active {item,option} index  We had various ordering issues, and now we properly sort all the notes which is awesome. However, there is this case where we still use the activeOptionIndex / activeItemIndex from before the sort happens. Now we will ensure that this is properly adjusted when performing the sort of the items. In addition, we will also properly adjust these values when registering and unregistering items, not only when performing actions.  update changelog","Adjust active {item,option} index (#1184)","adjust active {item,option} index We had various ordering issues, and now we properly sort all the notes which is awesome. However, there is this case where we still use the activeOptionIndex / activeItemIndex from before the sort happens. Now we will ensure that this is properly adjusted when performing the sort of the items. In addition, we will also properly adjust these values when registering and unregistering items, not only when performing actions. update changelog"
300,Fix double beforeEnter due to SSR (#1183)," prevent initial transitioning in SSR environment  Due to SSR and the hydration step, the transition code was already called even if we were not ready yet. This caused an issue where the beforeEnter callback got fired twice intead of once. Fixes: #311  update changelog",Fix double beforeEnter due to SSR (#1183),"prevent initial transitioning in SSR environment Due to SSR and the hydration step, the transition code was already called even if we were not ready yet. This caused an issue where the beforeEnter callback got fired twice intead of once. Fixes: #311 update changelog"
301,Reset Combobox Input when the value gets reset (#1181), reset input if value is reset  Fixes: #1177  update changelog,Reset Combobox Input when the value gets reset (#1181),reset input if value is reset Fixes: #1177 update changelog
302,Ensure that appear works regardless of multiple rerenders (#1179),  ensure that appear works regardless of multiple rerenders   remove incorrect afterLeave call   update changelog   only set the prevShow when using the unmount strategy ,Ensure that appear works regardless of multiple rerenders (#1179),ensure that appear works regardless of multiple rerenders remove incorrect afterLeave call update changelog only set the prevShow when using the unmount strategy
303,Improve outside click support (#1175)," improve outside click support  We used to use pointerdown, but some older devices with iOS 12 didn't have support for that. Instead we used mousedown. But now it turns out that some devices only properly use pointerdown and not the mousedown event. Instead, we will listen to both, but make sure to only handle the event once.  update changelog",Improve outside click support (#1175),"improve outside click support We used to use pointerdown, but some older devices with iOS 12 didn't have support for that. Instead we used mousedown. But now it turns out that some devices only properly use pointerdown and not the mousedown event. Instead, we will listen to both, but make sure to only handle the event once. update changelog"
304,Fix React <Transition> flicker issue (#1118),"  Fix React transition bug   use a ref instead of a useCallback (#1108)   This allows us to guarantee that the ref is always referencing the latest callback. This also allows us to re-run fewer effects because we don't really care about intermediate callback values, just the last one.   Fix tests   Update changelog   Co-authored-by: Robin Malfait malfait.robin@gmail.com",Fix React  flicker issue (#1118),"Fix React transition bug use a ref instead of a useCallback (#1108) This allows us to guarantee that the ref is always referencing the latest callback. This also allows us to re-run fewer effects because we don't really care about intermediate callback values, just the last one. Fix tests Update changelog Co-authored-by: Robin Malfait malfait.robin@gmail.com"
305,Guarantee DOM sort order when performing actions (#1168)," ensure proper sort order  We already fixed a bug in the past where the order of DOM nodes wasn't stored in the correct order when performing operations (e.g.: using your keyboard to go to the next option). We fixed this by ensuring that when we register/unregister an option/item, that we sorted the list properly. This worked fine, until we introduced the Combobox components. This is because items in a Combobox are continuously filtered and because of that moved around. Moving a DOM node to a new position doesn't require a full unmount/remount. This means that the sort gets messed up and the order is wrong when moving around again. To fix this, we will always perform a sort when performing actions. This could have performance drawbacks, but the alternative is to re-sort when the component gets updated. The bad part is that you can update a component via many ways (like changes on the parent), in those scenario's you probably don't care to properly re-order the internal list. Instead we do it while performing an action (goToOption / goToItem). To make things a bit more efficient, instead of querying the DOM all the time using document.querySelectorAll, we will keep track of the underlying DOM node instead. This does increase memory usage a bit but I think that this is a fine trade-off. Performance wise this could also be a bottleneck to perform the sorting if you have a lot of data. But this problem already exists today, therefore I consider this a complete new problem instead to solve. Maybe we don't solve it in Headless UI itself, but figure out a way to make it composable with existing virtualization libraries.  update changelog",Guarantee DOM sort order when performing actions (#1168),"ensure proper sort order We already fixed a bug in the past where the order of DOM nodes wasn't stored in the correct order when performing operations (e.g.: using your keyboard to go to the next option). We fixed this by ensuring that when we register/unregister an option/item, that we sorted the list properly. This worked fine, until we introduced the Combobox components. This is because items in a Combobox are continuously filtered and because of that moved around. Moving a DOM node to a new position doesn't require a full unmount/remount. This means that the sort gets messed up and the order is wrong when moving around again. To fix this, we will always perform a sort when performing actions. This could have performance drawbacks, but the alternative is to re-sort when the component gets updated. The bad part is that you can update a component via many ways (like changes on the parent), in those scenario's you probably don't care to properly re-order the internal list. Instead we do it while performing an action (goToOption / goToItem). To make things a bit more efficient, instead of querying the DOM all the time using document.querySelectorAll, we will keep track of the underlying DOM node instead. This does increase memory usage a bit but I think that this is a fine trade-off. Performance wise this could also be a bottleneck to perform the sorting if you have a lot of data. But this problem already exists today, therefore I consider this a complete new problem instead to solve. Maybe we don't solve it in Headless UI itself, but figure out a way to make it composable with existing virtualization libraries. update changelog"
306,Fix hover scroll (#1161),"  disable scroll when hover list item   change API a bit   fix scroll into view   For keyboard only for Combobox, Listbox and Menu for both React and Vue.  update changelog  Co-authored-by: yuta-ike 38308823+yuta-ike@users.noreply.github.com",Fix hover scroll (#1161),"disable scroll when hover list item change API a bit fix scroll into view For keyboard only for Combobox, Listbox and Menu for both React and Vue. update changelog Co-authored-by: yuta-ike 38308823+yuta-ike@users.noreply.github.com"
307,Improve SSR for Tab component (#1155),  improve SSR for Tabs   update changelog ,Improve SSR for Tab component (#1155),improve SSR for Tabs update changelog
308,Ensure links are triggered inside Popover Panel components (#1153),  ensure links are triggered inside Popover Panel components   update changelog ,Ensure links are triggered inside Popover Panel components (#1153),ensure links are triggered inside Popover Panel components update changelog
309,Fix Dialog usage in Tabs (#1149)," only record the restoreElement once enabled  Currently we are collecting the restoreElement even if the focus trap is not enabled. When we unmount we try to restore it. The problem is the moment you unmount you want to restore but only if the focus trap was enabled. Another issue is that the dialog state will be closed before we get to the onUmount hook. So there is probably a cleaner way to fix this, but this does the trick as well where we only record the restoreElement the moment the focus trap gets enabled.  update changelog",Fix Dialog usage in Tabs (#1149),"only record the restoreElement once enabled Currently we are collecting the restoreElement even if the focus trap is not enabled. When we unmount we try to restore it. The problem is the moment you unmount you want to restore but only if the focus trap was enabled. Another issue is that the dialog state will be closed before we get to the onUmount hook. So there is probably a cleaner way to fix this, but this does the trick as well where we only record the restoreElement the moment the focus trap gets enabled. update changelog"
310,Forward the ref to all components (#1116),  forward ref to all components   fix playground pages   This isn't a perfect fix of course. But the TypeScript changes required to do it properly are a bit bigger and require more work. Having this ready is a good step forward.  update changelog,Forward the ref to all components (#1116),forward ref to all components fix playground pages This isn't a perfect fix of course. But the TypeScript changes required to do it properly are a bit bigger and require more work. Having this ready is a good step forward. update changelog
311,Ensure that you can close the Combobox initially (#1148)," ensure that you can close the combobox initially  The issue is that onInput fires on every keystroke, and we also handled onChange which is triggered on blur in Vue. This means that the moment we blur, we also called the handleChange code to re-open the combobox because we want to open the combobox if something changes when the user starts typing. To fix this, we will splitup the logic so that it will only open the combobox on input but not on change.  update changelog",Ensure that you can close the Combobox initially (#1148),"ensure that you can close the combobox initially The issue is that onInput fires on every keystroke, and we also handled onChange which is triggered on blur in Vue. This means that the moment we blur, we also called the handleChange code to re-open the combobox because we want to open the combobox if something changes when the user starts typing. To fix this, we will splitup the logic so that it will only open the combobox on input but not on change. update changelog"
312,Make sure that the input syncs when the combobox closes (#1137),  make sure that the input syncs when the combobox closes   update changelog ,Make sure that the input syncs when the combobox closes (#1137),make sure that the input syncs when the combobox closes update changelog
313,Improve concurrency of GitHub Actions (#1128)," improve concurrency of GitHub Actions  This will allow you to cancel older running actions for the current PR / branch. This saves you some resources, but more importantly hopefully frees up some spots in the queue a bit faster. Saw this on the Node.js repo: https://github.com/nodejs/node/pull/42017  empty commit to trigger cancellation of previous commit",Improve concurrency of GitHub Actions (#1128),"improve concurrency of GitHub Actions This will allow you to cancel older running actions for the current PR / branch. This saves you some resources, but more importantly hopefully frees up some spots in the queue a bit faster. Saw this on the Node.js repo: link empty commit to trigger cancellation of previous commit"
314,improve demo mode,,improve demo mode,
315,add demo mode (__demoMode) (#1126),,add demo mode (__demoMode) (#1126),
316,1.5.0,,1.5.0,
317,update changelog,,update changelog,
318,Trigger scrollIntoView effect when position changes (#1113)," trigger scrollIntoView effect when position changes  This is important otherwise it could happen that the current active item is still the active item even if we inserted X items before the current one. This will result in the active item being out of the current viewport. To fix this, we will also make sure to trigger the effect if the position of the active item changes.  update changelog",Trigger scrollIntoView effect when position changes (#1113),"trigger scrollIntoView effect when position changes This is important otherwise it could happen that the current active item is still the active item even if we inserted X items before the current one. This will result in the active item being out of the current viewport. To fix this, we will also make sure to trigger the effect if the position of the active item changes. update changelog"
319,Fix off-by-one frame issue causing flicker (#1111),  Fix active item flicker   apply nextFrame -> requestAnimationFrame fix to other components   update changelog   Co-authored-by: Robin Malfait malfait.robin@gmail.com,Fix off-by-one frame issue causing flicker (#1111),Fix active item flicker apply nextFrame -> requestAnimationFrame fix to other components update changelog Co-authored-by: Robin Malfait malfait.robin@gmail.com
320,Move hold prop to the Combobox Options (#1109),  move hold prop to the Combobox Options   update changelog ,Move hold prop to the Combobox Options (#1109),move hold prop to the Combobox Options update changelog
321,Ensure ComboboxInput syncs correctly (#1106),  ensure ComboboxInput syncs correctly   update changelog ,Ensure ComboboxInput syncs correctly (#1106),ensure ComboboxInput syncs correctly update changelog
322,only call onChange if it exists,,only call onChange if it exists,
323,Bubble Escape event even if Combobox.Options is not rendered at all (#1104)," bubble Escape event even if Combobox.Options is not rendered at all  If you use <Combobox.Options static /> it means that you are in control of rendering and in that case we also bubble the Escape because you are in control of it. However, if you do something like this: js {filteredList.length > 0 && (   <Combobox.Options static>     ...   </Combobox.Options> )} Then whenever the filteredList is empty, the Combobox.Options are not rendered at all which means that we can't look at the static prop. To fix this, we also bubble the Escape event if we don't have a Combobox.Options at all so that the above example works as expected.  update changelog",Bubble Escape event even if Combobox.Options is not rendered at all (#1104),"bubble Escape event even if Combobox.Options is not rendered at all If you use  it means that you are in control of rendering and in that case we also bubble the Escape because you are in control of it. However, if you do something like this: js {filteredList.length > 0 && (        ...    )} Then whenever the filteredList is empty, the Combobox.Options are not rendered at all which means that we can't look at the static prop. To fix this, we also bubble the Escape event if we don't have a Combobox.Options at all so that the above example works as expected. update changelog"
324,Combobox improvements (#1101),  ensure combobox option gets activated on hover (while static)   rename combobox test file   remove leftover horizontal prop   remove unnecessary handleLeave calls   These are implemented on the Combobox.Option instead of the Combobox.Options. This allows you to have additional visual padding between Combobox.Options and Combobox.Option and if you hover over that area then the option becomes inactive. If we implement it on the Combobox.Options instead then this isn't that easy to do. We can do it by checking the target and whether or not it is inside a headlessui-combobox-option. This would only have a single listener instead of N listeners though. Potential improvements!   implement hold in favor of latestActiveOption   update changelog   Allow Escape to bubble when options is static   You’ve taken control of the open/close state yourself in which case this should be allowed to be handled by other event handlers Co-authored-by: Jordan Pittman jordan@cryptica.me,Combobox improvements (#1101),ensure combobox option gets activated on hover (while static) rename combobox test file remove leftover horizontal prop remove unnecessary handleLeave calls These are implemented on the Combobox.Option instead of the Combobox.Options. This allows you to have additional visual padding between Combobox.Options and Combobox.Option and if you hover over that area then the option becomes inactive. If we implement it on the Combobox.Options instead then this isn't that easy to do. We can do it by checking the target and whether or not it is inside a headlessui-combobox-option. This would only have a single listener instead of N listeners though. Potential improvements! implement hold in favor of latestActiveOption update changelog Allow Escape to bubble when options is static You’ve taken control of the open/close state yourself in which case this should be allowed to be handled by other event handlers Co-authored-by: Jordan Pittman jordan@cryptica.me
325,Ensure typeahead stays on same item if it still matches (#1098), ensure typeahead stays on same item if it still matches  Fixes: #1090  update changelog,Ensure typeahead stays on same item if it still matches (#1098),ensure typeahead stays on same item if it still matches Fixes: #1090 update changelog
326,Fix Combobox issues (#1099),"  Add combobox to Vue playground   Update input props   Wire up input event for changes   This fires changes whenever you type, not just on blur   Fix playground   Don't fire input event when pressing escape   The input event is only supposed to fire when the .value of the input changes. Pressing escape doesn't change the value of the input directly so it shouldn't fire.   Add latest active option render prop   Add missing active option props to Vue version   cleanup   Move test   Fix error   Add latest active option to Vue version   Tweak active option to not re-render   Remove refocusing on outside mousedown   Update tests   Forward refs on combobox to children   Cleanup code a bit   Fix lint problems on commit   Fix typescript issues   Update changelog ",Fix Combobox issues (#1099),"Add combobox to Vue playground Update input props Wire up input event for changes This fires changes whenever you type, not just on blur Fix playground Don't fire input event when pressing escape The input event is only supposed to fire when the .value of the input changes. Pressing escape doesn't change the value of the input directly so it shouldn't fire. Add latest active option render prop Add missing active option props to Vue version cleanup Move test Fix error Add latest active option to Vue version Tweak active option to not re-render Remove refocusing on outside mousedown Update tests Forward refs on combobox to children Cleanup code a bit Fix lint problems on commit Fix typescript issues Update changelog"
327,temporarily target es2019 instead of es2020 (#1083),The Headless UI docs require some bumps in packages because it currently can't handle es2020 features like ??. This tempory workaround should fix this in the mean time.,temporarily target es2019 instead of es2020 (#1083),The Headless UI docs require some bumps in packages because it currently can't handle es2020 features like ??. This tempory workaround should fix this in the mean time.
328,Ignore non-option roles (#1081),  rename ComboboxState to comboboxState for consistency   ensure all elements between role: listbox and role: option are marked as role: none   add test to demonstrate the role: none ,Ignore non-option roles (#1081),rename ComboboxState to comboboxState for consistency ensure all elements between role: listbox and role: option are marked as role: none add test to demonstrate the role: none
329,Remove orientation for Combobox (#1080),  remove orientation in Combobox (React)   remove orientation in Combobox (Vue) ,Remove orientation for Combobox (#1080),remove orientation in Combobox (React) remove orientation in Combobox (Vue)
330,Merge pull request #1078 from tailwindlabs/improve-build,Improve build files,Merge pull request #1078 from tailwindlabs/improve-build,Improve build files
331,make vue & react playground pages similar,"A bit out of scope for this issue, but bothered me while testing around 🙃",make vue & react playground pages similar,"A bit out of scope for this issue, but bothered me while testing around 🙃"
332,convert .js to .cjs,,convert .js to .cjs,
333,update changelog,,update changelog,
334,improve build files,Based on: https://nodejs.org/api/packages.html#conditional-exports,improve build files,Based on: link
335,Merge pull request #1071 from tailwindlabs/develop,Next release,Merge pull request #1071 from tailwindlabs/develop,Next release
336,only build @headlessui/react and @headlessui/vue,"This used to also build the individual playground packages but that's not needed on CI (nor locally). Because Vercel will build them for us. This will safe us some time on CI, since we can run them in parallel now and only build the actual libraries.",only build @headlessui/react and @headlessui/vue,"This used to also build the individual playground packages but that's not needed on CI (nor locally). Because Vercel will build them for us. This will safe us some time on CI, since we can run them in parallel now and only build the actual libraries."
337,"ensure that a path is passed to lint.sh, otherwise default to the current directory",,"ensure that a path is passed to lint.sh, otherwise default to the current directory",
338,document all scripts,,document all scripts,
339,move prettier-plugin-tailwindcss to dev dependencies,,move prettier-plugin-tailwindcss to dev dependencies,
340,Update type of omit,,Update type of omit,
341,Fix circular component types,,Fix circular component types,
342,Update minimum Vue to 3.2 (#1072),  Remove vercel json file   Don't use provide/inject outside of setup   Upgrade minimum vue version   Mark vue as an external   Update lockfile   WIP move render functions into setup   WIP   WIP   Use setup returning render fns for tests ,Update minimum Vue to 3.2 (#1072),Remove vercel json file Don't use provide/inject outside of setup Upgrade minimum vue version Mark vue as an external Update lockfile WIP move render functions into setup WIP WIP Use setup returning render fns for tests
343,"Improve overal codebase, use modern tech like esbuild and TypeScript 4! (#1055)","  use esbuild for React instead of tsdx   remove tsdx from Vue   use consistent names   add jest and prettier   update scripts   ignore some folders for prettier   run lint script instead of tsdx lint   run prettier en-masse   This has a few changes because of the new prettier version.   bump typescript to latest version   make typescript happy   cleanup playground package.json   make esbuild a dev dependency   make scripts consistent   fix husky hooks   add dedicated watch script   add yarn playground-react and yarn react-playground (alias)   This will make sure to run a watcher for the actual @headlessui/react package, and start a development server in the playground-react package.   ignore formatting in the .next folder   run prettier on playground-react package   setup playground-vue   Still not 100% working, but getting there!  add playground aliases in @headlessui/vue and @headlessui/react  This allows you to run yarn react playground or yarn vue playground from the root.   add clean script   move examples folder in playground-vue to root   ensure new lines for consistency in scripts   fix typescript issue   fix typescript issues in playgrounds   make sure to run prettier on everything it can   run prettier on all files   improve error output   If you minify the code, then it could happen that the errors are a bit obscure. This will hardcode the component name to improve errors.   add the prettier-plugin-tailwindcss plugin, party!   update changelog ","Improve overal codebase, use modern tech like esbuild and TypeScript 4! (#1055)","use esbuild for React instead of tsdx remove tsdx from Vue use consistent names add jest and prettier update scripts ignore some folders for prettier run lint script instead of tsdx lint run prettier en-masse This has a few changes because of the new prettier version. bump typescript to latest version make typescript happy cleanup playground package.json make esbuild a dev dependency make scripts consistent fix husky hooks add dedicated watch script add yarn playground-react and yarn react-playground (alias) This will make sure to run a watcher for the actual @headlessui/react package, and start a development server in the playground-react package. ignore formatting in the .next folder run prettier on playground-react package setup playground-vue Still not 100% working, but getting there! add playground aliases in @headlessui/vue and @headlessui/react This allows you to run yarn react playground or yarn vue playground from the root. add clean script move examples folder in playground-vue to root ensure new lines for consistency in scripts fix typescript issue fix typescript issues in playgrounds make sure to run prettier on everything it can run prettier on all files improve error output If you minify the code, then it could happen that the errors are a bit obscure. This will hardcode the component name to improve errors. add the prettier-plugin-tailwindcss plugin, party! update changelog"
344,Add Combobox component (#1047),"  start of combobox   start with a copy of the Listbox   WIP   Add Vue Combobox   Update Vue version of combobox   Update tests   Fix typescript errors in combobox test   Fix input label   The spec says that the combobox itself is labelled directly by the associated label. The button can however be labelled by the label or itself.   Add active descendant to combobox/input   Add listbox role to comobox options   Right now the option list is just a listbox. If we were to allow other types in the future this will need to be changable   Update tests   move React playground to dedicated package   add react playground script to root   ensure we only open/close the combobox when necessary   ensure export order is correct   remove leftover pages directory from React package   Only add aria controls when combobox is open   add missing next commands   make typescript happy   build @headlessui/react before building playground-react   add empty public folder   This makes vercel happy   wip   Add todo   Update tests   Still more updates to do but some are blocked on implementation   change default combobox example slightly   ensure that we sync the input with new state   When the  changes, then the input should change as well.   only sync the value with the input in a single spot   WIP: object value to string   WIP   WIP   WIP groups   Add static search filtering to combobox   Move mouse leave event to combobox   Fix use in fragments   Update   WIP   make all tests pass for the combobox in React   remove unnecessary playground item   remove listbox wip   only fire change event on inputs   Potentially we also have to do this for all kinds of form inputs. But this will do for now.   disable combobox vue tests   Fix vue typescript errors   Vue tests WIP   improve combobox playgrounds a tiny bit   ensure to lookup the correct value   make sure that we are using a div instead of a Fragment   expose activeItem   This will be similar to yourData[activeIndex], but in this case the active option's data. Can probably rename this if necessary!   Update comments   Port react tests to Vue   Vue tests WIP   WIP   Rename activeItem to activeOption   Move display value to input   Update playgrounds   Remove static filtering   Add tests for display value   WIP Vue Tests   WIP   unfocus suite   Cleanup react accessibility assertions code   Vue WIP   Cleanup errors in react interactions test utils   Update vue implementation   closer :D   Fix searching   Update   Add display value stubs   Update tests   move <Combobox onSearch={} /> to <Combobox.Input onChange={} />   use useLatestValue hook   make onChange explicitly required   remove unused variables   move <Combobox @search="""" /> to <ComboboxInput @change="""" />   use correct event   use let for consistency   remove unnecessary hidden check   implement displayValue for Vue   update playground to reflect changes   make sure that the activeOptionIndex stays correct   update changelog   Co-authored-by: Jordan Pittman jordan@cryptica.me",Add Combobox component (#1047),"start of combobox start with a copy of the Listbox WIP Add Vue Combobox Update Vue version of combobox Update tests Fix typescript errors in combobox test Fix input label The spec says that the combobox itself is labelled directly by the associated label. The button can however be labelled by the label or itself. Add active descendant to combobox/input Add listbox role to comobox options Right now the option list is just a listbox. If we were to allow other types in the future this will need to be changable Update tests move React playground to dedicated package add react playground script to root ensure we only open/close the combobox when necessary ensure export order is correct remove leftover pages directory from React package Only add aria controls when combobox is open add missing next commands make typescript happy build @headlessui/react before building playground-react add empty public folder This makes vercel happy wip Add todo Update tests Still more updates to do but some are blocked on implementation change default combobox example slightly ensure that we sync the input with new state When the  changes, then the input should change as well. only sync the value with the input in a single spot WIP: object value to string WIP WIP WIP groups Add static search filtering to combobox Move mouse leave event to combobox Fix use in fragments Update WIP make all tests pass for the combobox in React remove unnecessary playground item remove listbox wip only fire change event on inputs Potentially we also have to do this for all kinds of form inputs. But this will do for now. disable combobox vue tests Fix vue typescript errors Vue tests WIP improve combobox playgrounds a tiny bit ensure to lookup the correct value make sure that we are using a div instead of a Fragment expose activeItem This will be similar to yourData[activeIndex], but in this case the active option's data. Can probably rename this if necessary! Update comments Port react tests to Vue Vue tests WIP WIP Rename activeItem to activeOption Move display value to input Update playgrounds Remove static filtering Add tests for display value WIP Vue Tests WIP unfocus suite Cleanup react accessibility assertions code Vue WIP Cleanup errors in react interactions test utils Update vue implementation closer :D Fix searching Update Add display value stubs Update tests move  to  use useLatestValue hook make onChange explicitly required remove unused variables move  to  use correct event use let for consistency remove unnecessary hidden check implement displayValue for Vue update playground to reflect changes make sure that the activeOptionIndex stays correct update changelog Co-authored-by: Jordan Pittman jordan@cryptica.me"
345,Remove playground (#1053),  remove local testing playgrounds   bump outdated packages ,Remove playground (#1053),remove local testing playgrounds bump outdated packages
346,Improve typeahead search logic (#1051)," improve typeahead search logic  This ensures that if you have 4 items: - Alice - Bob - Charlie - Bob And you search for b, then you jump to the first Bob, but if yuo search again for b then we used to go to the very first Bob because we always searched from the top. Now we will search from the active item and onwards. Which means that we will now jump to the second Bob.  update changelog",Improve typeahead search logic (#1051),"improve typeahead search logic This ensures that if you have 4 items: - Alice - Bob - Charlie - Bob And you search for b, then you jump to the first Bob, but if yuo search again for b then we used to go to the very first Bob because we always searched from the top. Now we will search from the active item and onwards. Which means that we will now jump to the second Bob. update changelog"
347,Improve controlled Tabs behaviour (#1050),  Append tests for Tab.Group's selectedIndex.   ensure that we correctly use the incoming selectedIndex   update changelog   Co-authored-by: Ryoga Kitagawa ryoga.kitagawa@gmail.com,Improve controlled Tabs behaviour (#1050),Append tests for Tab.Group's selectedIndex. ensure that we correctly use the incoming selectedIndex update changelog Co-authored-by: Ryoga Kitagawa ryoga.kitagawa@gmail.com
348,"Ensure correct order when conditionally rendering Menu.Item, Listbox.Option and RadioGroup.Option (#1045)","  ensure correct order in Menu.Item   Update Vue version of menu component ordering issue   ensure correct order of Listbox.Options   add test to verify that RadioGroup.Option order is correct   ensure correct order of ListboxOptions   cleanup   add test to verify that RadioGroupOption order is correct   update changelog   use similar a,z signature compared to other places   Co-authored-by: Jordan Pittman jordan@cryptica.me","Ensure correct order when conditionally rendering Menu.Item, Listbox.Option and RadioGroup.Option (#1045)","ensure correct order in Menu.Item Update Vue version of menu component ordering issue ensure correct order of Listbox.Options add test to verify that RadioGroup.Option order is correct ensure correct order of ListboxOptions cleanup add test to verify that RadioGroupOption order is correct update changelog use similar a,z signature compared to other places Co-authored-by: Jordan Pittman jordan@cryptica.me"
349,Simplify and improve overall structure (#1044),  simplify CI and make it consistent with CI of tailwindcss   add contributing guidelines   use correct org name   ensure yarn lint is fully passing without warnings   add subject to change message for insiders build ,Simplify and improve overall structure (#1044),simplify CI and make it consistent with CI of tailwindcss add contributing guidelines use correct org name ensure yarn lint is fully passing without warnings add subject to change message for insiders build
350,Next release (#1039),  placeholder for next release   improve consistency of changelog ,Next release (#1039),placeholder for next release improve consistency of changelog
351,1.4.3,,1.4.3,
352,update changelog,,update changelog,
353,cleanup older changelog items,,cleanup older changelog items,
354,Next release (#916),"  placeholder for next release   Ensure portal root exists in the DOM (#950)   ensure that the portal root is always in the DOM   When using NextJS, it happens that between page transitions the portal root gets removed form the DOM. We will check the DOM when the target updates, and if it doesn't exist anymore, then we will re-insert it in the DOM.   update changelog   Allow Tabs to be controllable (#970)   feat(react): Allow Tab Component to be controlled   fix falsy bug   selectedIndex || defaultIndex would result in the defaultIndex if selectedIndex is set to 0. This means that if you have this code: js <Tab.Group selectedIndex={0} defaultIndex={2} /> That you will never be able to see the very first tab, unless you provided a negative value like -1. selectedIndex ?? defaultIndex fixes this, since it purely checkes for undefined and null.   implemented controllable Tabs for Vue   add dedicated test to ensure changing the defaultIndex has no effect   update changelog   Co-authored-by: ChiefORZ seb.schaffernak@gmail.com  Fix missing key binding in examples (#1036)  Co-authored-by: superDragon xkloveme@gmail.com  Fix slice => splice typo in Vue Tabs component (#1037)  Co-authored-by: Ryan Gossiaux ryan.gossiaux@gmail.com   update changelog   Ensure correct DOM node order when performing focus actions (#1038)   ensure that the order of DOM nodes is correct   When we are performing actions like focusIn(list, Focus.First) then we have to ensrue that we are working with the correct list that is properly sorted. It can happen that the list of DOM nodes is out of sync. This can happen if you have 3 Tabs, hide the second (which triggers an unmount and an unregister of the Tab), then re-add the second item in the middle. This will re-add the item to the end of the list instead of in the middle. We can solve this by always sorting items when we are adding / removing items, but this is a bit more error prone because it is easy to forget. Instead we will sort it when performing the actual keyboard action. If we didn't provide a list but an element, then we use a getFocusableElements(element) function, but this already gives you a correctly sorted list so we don't need to do that for this list.   add tests to prove the correct order when performing actions   cleanup code just for tests   It could still happen that this internal list is not ordered correctly but that's not really a problem we just have the list to keep track of things. For our tests we now use the position from the DOM directly.  update changelog  Co-authored-by: ChiefORZ seb.schaffernak@gmail.com Co-authored-by: superDragon xkloveme@gmail.com Co-authored-by: Ryan Gossiaux ryan.gossiaux@gmail.com",Next release (#916),"placeholder for next release Ensure portal root exists in the DOM (#950) ensure that the portal root is always in the DOM When using NextJS, it happens that between page transitions the portal root gets removed form the DOM. We will check the DOM when the target updates, and if it doesn't exist anymore, then we will re-insert it in the DOM. update changelog Allow Tabs to be controllable (#970) feat(react): Allow Tab Component to be controlled fix falsy bug selectedIndex || defaultIndex would result in the defaultIndex if selectedIndex is set to 0. This means that if you have this code: js  That you will never be able to see the very first tab, unless you provided a negative value like -1. selectedIndex ?? defaultIndex fixes this, since it purely checkes for undefined and null. implemented controllable Tabs for Vue add dedicated test to ensure changing the defaultIndex has no effect update changelog Co-authored-by: ChiefORZ seb.schaffernak@gmail.com Fix missing key binding in examples (#1036) Co-authored-by: superDragon xkloveme@gmail.com Fix slice => splice typo in Vue Tabs component (#1037) Co-authored-by: Ryan Gossiaux ryan.gossiaux@gmail.com update changelog Ensure correct DOM node order when performing focus actions (#1038) ensure that the order of DOM nodes is correct When we are performing actions like focusIn(list, Focus.First) then we have to ensrue that we are working with the correct list that is properly sorted. It can happen that the list of DOM nodes is out of sync. This can happen if you have 3 Tabs, hide the second (which triggers an unmount and an unregister of the Tab), then re-add the second item in the middle. This will re-add the item to the end of the list instead of in the middle. We can solve this by always sorting items when we are adding / removing items, but this is a bit more error prone because it is easy to forget. Instead we will sort it when performing the actual keyboard action. If we didn't provide a list but an element, then we use a getFocusableElements(element) function, but this already gives you a correctly sorted list so we don't need to do that for this list. add tests to prove the correct order when performing actions cleanup code just for tests It could still happen that this internal list is not ordered correctly but that's not really a problem we just have the list to keep track of things. For our tests we now use the position from the DOM directly. update changelog Co-authored-by: ChiefORZ seb.schaffernak@gmail.com Co-authored-by: superDragon xkloveme@gmail.com Co-authored-by: Ryan Gossiaux ryan.gossiaux@gmail.com"
355,Tweak wording in changelog (#917),,Tweak wording in changelog (#917),
356,bump to 1.4.2,,bump to 1.4.2,
357,update GitHub action name,,update GitHub action name,
358,update changelog,,update changelog,
359,Merge pull request #826 from tailwindlabs/develop,Next release,Merge pull request #826 from tailwindlabs/develop,Next release
360,Fix type on Tabs component Vue (#912),  add tabs example to Vue   use useResolveButtonType for Tabs   update changelog ,Fix type on Tabs component Vue (#912),add tabs example to Vue use useResolveButtonType for Tabs update changelog
361,update issue templates,,update issue templates,
362,update changelog,,update changelog,
363,Enable tree shaking in Vue package (#859),,Enable tree shaking in Vue package (#859),
364,Rely on initial state of Transition component (#882),The useId hook causes a re-render in TransitionChild immediately after mount which triggers a transition by initial being false in the second re-render regardless of how appear was set.,Rely on initial state of Transition component (#882),The useId hook causes a re-render in TransitionChild immediately after mount which triggers a transition by initial being false in the second re-render regardless of how appear was set.
365,fix: vue ssr (#867),closes #840,fix: vue ssr (#867),closes #840
366,Ensure interactability with Popover.Panel contents in static mode (#857),  ensure interactability with Popover.Panel contents in static mode   update changelog ,Ensure interactability with Popover.Panel contents in static mode (#857),ensure interactability with Popover.Panel contents in static mode update changelog
367,Add automated release workflows (#853),"This commit also contains new code introduced after the PR in #853 was merged. I just squashed it all together to prevent noisy commits to try and fix CI. The funny thing is that now the final commit looks fairly stupid/simple but it wasn't that easy as I would have liked.  Couldn't find a proper way to execute npm version using yarn    workspaces. yarn workspaces foreach npm version would have worked    if we were using Yarn 2 instead of Yarn 1. Introducing version and publish scripts in both packages worked,    but then the default version and publish were also executed. Once I made the scripts unique (npm-version,  npm-publish) it    worked~ish. The registry was always set to a yarnpkg registry, even    if we set the registry in CI and in a local .npmrc file. My guess is    that we are executing in a nested directory and therefore it didn't    work. Next, I found the npm workspaces option so that we can use that in    addition to yarn workspaces 🙃 In CI of course this didn't work, because I was not using the same    node version... After everything worked, I did cleanup of the new scripts, and    removed the introduced .npmrc files.",Add automated release workflows (#853),"This commit also contains new code introduced after the PR in #853 was merged. I just squashed it all together to prevent noisy commits to try and fix CI. The funny thing is that now the final commit looks fairly stupid/simple but it wasn't that easy as I would have liked. Couldn't find a proper way to execute npm version using yarn    workspaces. yarn workspaces foreach npm version would have worked    if we were using Yarn 2 instead of Yarn 1. Introducing version and publish scripts in both packages worked,    but then the default version and publish were also executed. Once I made the scripts unique (npm-version,  npm-publish) it    worked~ish. The registry was always set to a yarnpkg registry, even    if we set the registry in CI and in a local .npmrc file. My guess is    that we are executing in a nested directory and therefore it didn't    work. Next, I found the npm workspaces option so that we can use that in    addition to yarn workspaces 🙃 In CI of course this didn't work, because I was not using the same    node version... After everything worked, I did cleanup of the new scripts, and    removed the introduced .npmrc files."
368,Use watchEffect instead of immediately using an event listener on window (#817),  use watchEffect instead of immediately using an event listener on window   update changelog ,Use watchEffect instead of immediately using an event listener on window (#817),use watchEffect instead of immediately using an event listener on window update changelog
369,Allow to click on elements inside a Dialog Overlay (#816),  allow to click on elements inside a Dialog Overlay   update changelog ,Allow to click on elements inside a Dialog Overlay (#816),allow to click on elements inside a Dialog Overlay update changelog
370,Merge pull request #798 from tailwindlabs/stop-propagation-on-escape,Ensure we stop the event from propagating,Merge pull request #798 from tailwindlabs/stop-propagation-on-escape,Ensure we stop the event from propagating
371,update changelog,,update changelog,
372,ensure we stop the event from propagating,,ensure we stop the event from propagating,
373,bump version to 1.4.1,,bump version to 1.4.1,
374,update changelog,,update changelog,
375,Merge pull request #713 from tailwindlabs/develop,Next release,Merge pull request #713 from tailwindlabs/develop,Next release
376,Warn instead of error when there are no focusable elements (#775),  warn instead of error when there are no focusable elements   update changelog   Co-authored-by: Krystof Rehacek krystofee@gmail.com,Warn instead of error when there are no focusable elements (#775),warn instead of error when there are no focusable elements update changelog Co-authored-by: Krystof Rehacek krystofee@gmail.com
377,Fix broken escape key behaviour (#754)," fix broken escape key behaviour  We've ""fixed"" an issue when we had nested Dialogs (#430). The escape would not close the correct Dialog. The issue here was with the logic to know whether we were the last Dialog or not. The issue was not how we implemented the close functionality. To make things easier, we moved the global window event to a scoped div (the Dialog itself). While that fixed the nested Dialog issue, it introduced this bug where escape would not close if you click on a non-focusable element like a span in the Dialog. Since that PR we did a bunch of improvements on how the underlying ""stacking"" system worked. This PR reverts to the ""global"" window event listener so that we can still catch all of the escape keydown events. Fixes: #524 Fixes: #693  update changelog",Fix broken escape key behaviour (#754),"fix broken escape key behaviour We've ""fixed"" an issue when we had nested Dialogs (#430). The escape would not close the correct Dialog. The issue here was with the logic to know whether we were the last Dialog or not. The issue was not how we implemented the close functionality. To make things easier, we moved the global window event to a scoped div (the Dialog itself). While that fixed the nested Dialog issue, it introduced this bug where escape would not close if you click on a non-focusable element like a span in the Dialog. Since that PR we did a bunch of improvements on how the underlying ""stacking"" system worked. This PR reverts to the ""global"" window event listener so that we can still catch all of the escape keydown events. Fixes: #524 Fixes: #693 update changelog"
378,Add Vue emit types (#712),  Add Vue emit types   ensure value is a boolean   Even though we only use false for now   add Vue emit types for Tabs component   update changelog   Co-authored-by: henribru 6639509+henribru@users.noreply.github.com,Add Vue emit types (#712),Add Vue emit types ensure value is a boolean Even though we only use false for now add Vue emit types for Tabs component update changelog Co-authored-by: henribru 6639509+henribru@users.noreply.github.com
379,Only add type=button for real buttons (#709)," add {type:'button'} only for buttons  We will try and infer the type based on the passed in props.as prop or the default tag. However, when somebody uses as={CustomComponent} then we don't know what it will render. Therefore we have to pass it a ref and check if the final result is a button or not. If it is, and it doesn't have a type yet, then we can set the type correctly.  update changelog",Only add type=button for real buttons (#709),"add {type:'button'} only for buttons We will try and infer the type based on the passed in props.as prop or the default tag. However, when somebody uses as={CustomComponent} then we don't know what it will render. Therefore we have to pass it a ref and check if the final result is a button or not. If it is, and it doesn't have a type yet, then we can set the type correctly. update changelog"
380,bump version to 1.4.0,,bump version to 1.4.0,
381,update changelog,,update changelog,
382,Merge pull request #702 from tailwindlabs/develop,Next release,Merge pull request #702 from tailwindlabs/develop,Next release
383,update changelog,,update changelog,
384,Change Tabs api (#698), Change Tabs API (React)  | Before        | After        | | ------------- | ------------ | | Tabs        | Tab.Group  | | Tabs.List   | Tab.List   | | Tabs.Tab    | Tab        | | Tabs.Panels | Tab.Panels | | Tabs.Panel  | Tab.Panel  |  Change Tabs API (Vue)  | Before       | After       | | ------------ | ----------- | | Tabs       | TabGroup  | | TabsList   | TabList   | | TabsTab    | Tab       | | TabsPanels | TabPanels | | TabsPanel  | TabPanel  |   change playground example for Tabs (React)   update changelog ,Change Tabs api (#698),Change Tabs API (React) | Before        | After        | | ------------- | ------------ | | Tabs        | Tab.Group  | | Tabs.List   | Tab.List   | | Tabs.Tab    | Tab        | | Tabs.Panels | Tab.Panels | | Tabs.Panel  | Tab.Panel  | Change Tabs API (Vue) | Before       | After       | | ------------ | ----------- | | Tabs       | TabGroup  | | TabsList   | TabList   | | TabsTab    | Tab       | | TabsPanels | TabPanels | | TabsPanel  | TabPanel  | change playground example for Tabs (React) update changelog
385,Expose close functionality via render prop (#697),  expose a close function via the render prop for the Popover and Popover.Panel components (React)   expose a close function via the render prop for the Disclosure and Disclosure.Panel components (React)   expose a close function via the render prop for the Popover and PopoverPanel components (Vue)   expose a close function via the render prop for the Disclosure and DisclosurePanel components (Vue) ,Expose close functionality via render prop (#697),expose a close function via the render prop for the Popover and Popover.Panel components (React) expose a close function via the render prop for the Disclosure and Disclosure.Panel components (React) expose a close function via the render prop for the Popover and PopoverPanel components (Vue) expose a close function via the render prop for the Disclosure and DisclosurePanel components (Vue)
386,move manual prop to correct spot in demo,,move manual prop to correct spot in demo,
387,Add aria-orientation to the Listbox component (#683)," add aria-orientation to the Listbox component  By default the Listbox will have an orientation of vertical. When you pass the horizontal prop to the Listbox component then the aria-orientation will be set to horizontal. Additionally, we swap the previous/next keys:  Vertical: ArrowUp/ArrowDown  Horizontal: ArrowLeft/ArrowRight   update changelog ",Add aria-orientation to the Listbox component (#683),"add aria-orientation to the Listbox component By default the Listbox will have an orientation of vertical. When you pass the horizontal prop to the Listbox component then the aria-orientation will be set to horizontal. Additionally, we swap the previous/next keys: Vertical: ArrowUp/ArrowDown Horizontal: ArrowLeft/ArrowRight update changelog"
388,Add ability to use Disclosure.Button inside a Disclosure.Panel (#682)," add ability to use Disclosure.Button inside a Disclosure.Panel  If you do it this way, then the Disclosure.Button will function as a close button. This will make it consistent with the Popover.Button inside the Popover.Panel funcitonality.  update changelog",Add ability to use Disclosure.Button inside a Disclosure.Panel (#682),"add ability to use Disclosure.Button inside a Disclosure.Panel If you do it this way, then the Disclosure.Button will function as a close button. This will make it consistent with the Popover.Button inside the Popover.Panel funcitonality. update changelog"
389,add Tabs component (#674),  add Tabs component (React)   expose Tabs component (React)   add Tabs example (React)   add Tabs component (Vue)   expose Tabs component (Vue)   update changelog ,add Tabs component (#674),add Tabs component (React) expose Tabs component (React) add Tabs example (React) add Tabs component (Vue) expose Tabs component (Vue) update changelog
390,improve changelog,,improve changelog,
391,improve changelog,,improve changelog,
392,bump version to 1.3.0,,bump version to 1.3.0,
393,update changelog,,update changelog,
394,Merge pull request #513 from tailwindlabs/develop,Next release,Merge pull request #513 from tailwindlabs/develop,Next release
395,Improve react peer deps (#622), ensure react-dom is also a peer dependency  Co-authored-by: =?UTF-8?q?S=C3=A9bastien=20Vanvelthem?= belgattitude@gmail.com   prepare peer dependencies for React 18   update changelog   Co-authored-by: =?UTF-8?q?S=C3=A9bastien=20Vanvelthem?= belgattitude@gmail.com,Improve react peer deps (#622),ensure react-dom is also a peer dependency Co-authored-by: =?UTF-8?q?S=C3=A9bastien=20Vanvelthem?= belgattitude@gmail.com prepare peer dependencies for React 18 update changelog Co-authored-by: =?UTF-8?q?S=C3=A9bastien=20Vanvelthem?= belgattitude@gmail.com
396,update changelog,,update changelog,
397,Support tree-shaking by enabling preserveModules (#602),,Support tree-shaking by enabling preserveModules (#602),
398,fix failing menu test,,fix failing menu test,
399,Remove explicit class prop (#608) (#608),,Remove explicit class prop (#608) (#608),
400,Make Listbox types consistent (#576),  Make Listbox types consistent   update changelog   Co-authored-by: Robin Malfait malfait.robin@gmail.com,Make Listbox types consistent (#576),Make Listbox types consistent update changelog Co-authored-by: Robin Malfait malfait.robin@gmail.com
401,remove classname feature (#607), change className to class  Co-authored-by: Ryan Johnston ryan@magic.nz   drop className as a function in Vue   update changelog   Co-authored-by: Ryan Johnston ryan@magic.nz,remove classname feature (#607),change className to class Co-authored-by: Ryan Johnston ryan@magic.nz drop className as a function in Vue update changelog Co-authored-by: Ryan Johnston ryan@magic.nz
402,Improve aria accessibility (#592),  encode expected aria-expanded behaviour   ensure aria-expanded has the correct value   aria-expanded can be in 3 different states: | Value               | Description                                                                | | ------------------- | -------------------------------------------------------------------------- | | false               | The grouping element this element owns or controls is collapsed.           | | true                | The grouping element this element owns or controls is expanded.            | | undefined (default) | The element does not own or control a grouping element that is expandable. | Ref: https://www.w3.org/TR/wai-aria-1.2/#aria-expanded Fixes: #580   ensure disabled prop in Vue is not rendered when false   update changelog ,Improve aria accessibility (#592),encode expected aria-expanded behaviour ensure aria-expanded has the correct value aria-expanded can be in 3 different states: | Value               | Description                                                                | | ------------------- | -------------------------------------------------------------------------- | | false               | The grouping element this element owns or controls is collapsed.           | | true                | The grouping element this element owns or controls is expanded.            | | undefined (default) | The element does not own or control a grouping element that is expandable. | Ref: link Fixes: #580 ensure disabled prop in Vue is not rendered when false update changelog
403,Fix missing type causing prop check error (#554),  fix: missing type causing prop check error   update changelog   Co-authored-by: anzharip 10259593+anzharip@users.noreply.github.com,Fix missing type causing prop check error (#554),fix: missing type causing prop check error update changelog Co-authored-by: anzharip 10259593+anzharip@users.noreply.github.com
404,Update react peer dependency version range (#544),  update react peer dependency version range   update changelog ,Update react peer dependency version range (#544),update react peer dependency version range update changelog
405,add aria-disabled to RadioGroup Options (#543), add aria-disabled to RadioGroup Options  This will happen when: - The RadioGroup is disabled - The RadioGroup Option is disabled Closes: #515  update changelog,add aria-disabled to RadioGroup Options (#543),add aria-disabled to RadioGroup Options This will happen when: - The RadioGroup is disabled - The RadioGroup Option is disabled Closes: #515 update changelog
406,Improve Vue reactivity & disabled prop (#512),  only destructure from props inside render   conditionally ensure that tabindex -1 exists   reflect disabled prop in React as well   update changelog ,Improve Vue reactivity & disabled prop (#512),only destructure from props inside render conditionally ensure that tabindex -1 exists reflect disabled prop in React as well update changelog
407,Add entered prop to Transition components (#504),  introduce entered prop on the Transition components   update Dialog examples to make use of the entered prop ,Add entered prop to Transition components (#504),introduce entered prop on the Transition components update Dialog examples to make use of the entered prop
408,Ensure that you can use Transition Child components in more scenario's (#503)," ensure that you can use Transition Child components  When you are using the implicit variants of the components, for example when you are using a Transition component inside a Menu component then it might look weird in Vue. The Vue code could look like this: ```   ...   ```  However, `TransitionRoot` doesn't make much sense here because it sits in the middle of 2 components, and it is also not controlled by an explicit `show` prop.  This commit will allows you to use a `TransitionChild` instead (in fact, both work).  We basically now do a few things, when you are using a TransitionChild:  - Do we have a parent `TransitionRoot`? Yes -> Use it - Do we have an open closed state? Yes -> Render a TransitionRoot in   between behind the scenes. - Throw the error we were throwing before!  * update changelog",Ensure that you can use Transition Child components in more scenario's (#503),"ensure that you can use Transition Child components When you are using the implicit variants of the components, for example when you are using a Transition component inside a Menu component then it might look weird in Vue. The Vue code could look like this: ``` ... ``` However, module doesn't make much sense here because it sits in the middle of 2 components, and it is also not controlled by an explicit module prop. This commit will allows you to use a module instead (in fact, both work). We basically now do a few things, when you are using a TransitionChild:  Do we have a parent module? Yes -> Use it Do we have an open closed state? Yes -> Render a TransitionRoot in   between behind the scenes.  Throw the error we were throwing before!   update changelog "
409,bump versions,,bump versions,
410,prepare changelog,,prepare changelog,
411,Merge pull request #501 from tailwindlabs/develop,Next release,Merge pull request #501 from tailwindlabs/develop,Next release
412,Fix incorrect nested Dialogs behaviour (#489),"  add tests to verify the nested Dialog behaviour   set mounted to true once rendered once   cache useWindowEvent listener   We only care about the very last version of the listener function. This allows us to only change the event listener if the event name (string) and options (boolean | object) change.  add/delete messages when mounting/unmounting  We don't require a dedicated hook anymore, so this is a bit of cleanup!   add comments to the FocusResult enum   splitup functionality and make it a bit more clear using feature flags   add getDialogOverlays helper   simplify the Portal component   We don't need to add the current element to the Stack. We only want to take care of that in the Dialog component itself.  drop dom-containers  Currently it is only used in a single spot, so I inlined it into that file.   simplify the FocusTrap component, use new API   improve Dialog component   update CHANGELOG ",Fix incorrect nested Dialogs behaviour (#489),"add tests to verify the nested Dialog behaviour set mounted to true once rendered once cache useWindowEvent listener We only care about the very last version of the listener function. This allows us to only change the event listener if the event name (string) and options (boolean | object) change. add/delete messages when mounting/unmounting We don't require a dedicated hook anymore, so this is a bit of cleanup! add comments to the FocusResult enum splitup functionality and make it a bit more clear using feature flags add getDialogOverlays helper simplify the Portal component We don't need to add the current element to the Stack. We only want to take care of that in the Dialog component itself. drop dom-containers Currently it is only used in a single spot, so I inlined it into that file. simplify the FocusTrap component, use new API improve Dialog component update CHANGELOG"
413,Improve dialog and SSR (#477)," delay initialization of Dialog  We were using a useLayoutEffect, now let's use a useEffect instead. It still moves focus to the correct element, but that process is now a bit delayed. This means that users will less-likely be urged to ""hack"" around the issue by using fake focusable elements which will result in worse accessibility.  add hook to deal with server handoff  This will allow us to delay certain features. For example we can delay the focus trapping until it is fully hydrated. We can also delay rendering the Portal to ensure hydration works correctly.   use server handoff complete hook   update changelog ",Improve dialog and SSR (#477),"delay initialization of Dialog We were using a useLayoutEffect, now let's use a useEffect instead. It still moves focus to the correct element, but that process is now a bit delayed. This means that users will less-likely be urged to ""hack"" around the issue by using fake focusable elements which will result in worse accessibility. add hook to deal with server handoff This will allow us to delay certain features. For example we can delay the focus trapping until it is fully hydrated. We can also delay rendering the Portal to ensure hydration works correctly. use server handoff complete hook update changelog"
414,parallelize GitHub actions (#463),,parallelize GitHub actions (#463),
415,Open closed state (#466),"  simplify examples by using the implicit open/closed state   introduce Open/Closed context (React)   use Open/Closed context in Dialog component (React)   use Open/Closed context in Disclosure component (React)   use Open/Closed context in Listbox component (React)   use Open/Closed context in Menu component (React)   use Open/Closed context in Popover component (React)   use Open/Closed context in Transition component (React)   introduce Open/Closed context (Vue)   use Open/Closed context in Dialog component (Vue)   use Open/Closed context in Disclosure component (Vue)   use Open/Closed context in Listbox component (Vue)   use Open/Closed context in Menu component (Vue)   use Open/Closed context in Popover component (Vue)   use Open/Closed context in Transition component (Vue)   use a ref in the Description comopnent   This allows us to update the ref and everything should work after that. Currently we only saw the ""current"" state.   add more Vue examples   update changelog ",Open closed state (#466),"simplify examples by using the implicit open/closed state introduce Open/Closed context (React) use Open/Closed context in Dialog component (React) use Open/Closed context in Disclosure component (React) use Open/Closed context in Listbox component (React) use Open/Closed context in Menu component (React) use Open/Closed context in Popover component (React) use Open/Closed context in Transition component (React) introduce Open/Closed context (Vue) use Open/Closed context in Dialog component (Vue) use Open/Closed context in Disclosure component (Vue) use Open/Closed context in Listbox component (Vue) use Open/Closed context in Menu component (Vue) use Open/Closed context in Popover component (Vue) use Open/Closed context in Transition component (Vue) use a ref in the Description comopnent This allows us to update the ref and everything should work after that. Currently we only saw the ""current"" state. add more Vue examples update changelog"
416,update changelog,,update changelog,
417,bump versions,,bump versions,
418,Merge pull request #462 from tailwindlabs/develop,Next release,Merge pull request #462 from tailwindlabs/develop,Next release
419,fix v-model typescript error (#461),  fix v-model typescript error   update changelog   Fixes: #368 Fixes: #457 Closes: #459 Co-authored-by: Andrea Nanni andrea.nanni3@gmail.com,fix v-model typescript error (#461),fix v-model typescript error update changelog Fixes: #368 Fixes: #457 Closes: #459 Co-authored-by: Andrea Nanni andrea.nanni3@gmail.com
420,fix clicks and form submissions in Dialog component (#460), fix clicks and form submissions in Dialog component  Fixes: #451  update changelog,fix clicks and form submissions in Dialog component (#460),fix clicks and form submissions in Dialog component Fixes: #451 update changelog
421,fix changelog,,fix changelog,
422,bump version to 1.1.0,,bump version to 1.1.0,
423,update changelog,,update changelog,
424,Next release (#431),"  Fixed typos (#350)   chore: Fix typo in render.ts (#347)   Better vue link (#353)   Better vue link   add better React link   Co-authored-by: Robin Malfait malfait.robin@gmail.com   Enable NoScroll feature for the initial useFocusTrap hook (#356)   enable NoScroll feature for the initial useFocusTrap hook   Once you are using Tab and Shift+Tab it does the scrolling. Fixes: #345   update changelog   Revert ""Enable NoScroll feature for the initial useFocusTrap hook (#356)""   This reverts commit 19590b07624d7e3d751cbf11de869dfb0ea432ba. Solution is not 100% correct, so will revert for now!   Improve search (#385)   make search case insensitive for the listbox   make search case insensitive for the menu   update changelog   add disabled prop to RadioGroup and RadioGroup Option (#401)   add disabled prop to RadioGroup and RadioGroup Option   Also did some general cleanup which in turn fixed an issue where the RadioGroup is unreachable when a value is used that doesn't exist in the list of options. Fixes: #378   update changelog   Fix type of RadioGroupOption (#400)   Match RadioGroupOption value types to match modelValue allowed types for RadioGroup   update changelog   fix typo's   chore(CI): update main workflow (#395)   chore(CI): update main workflow   Update main.yml   fix dialog event propagation (#422)   re-export the screen utility for quick debugging purposes   stop event propagation when clicking inside a Dialog   Fixes: #414   improve dialog escape (#430)   Make sure that Escape only closes the top most Dialog   update changelog   add defaultOpen prop to Disclosure component (#447)   add defaultOpen prop to Disclosure component   update changelog   Co-authored-by: Shuvro Roy shuvro.roy@northsouth.edu Co-authored-by: Alex Nault nault.alex@gmail.com Co-authored-by: Eugene Kopich github@web2033.com Co-authored-by: Nathan Shoemark n.shoemark@gmail.com Co-authored-by: Michaël De Boey info@michaeldeboey.be",Next release (#431),"Fixed typos (#350) chore: Fix typo in render.ts (#347) Better vue link (#353) Better vue link add better React link Co-authored-by: Robin Malfait malfait.robin@gmail.com Enable NoScroll feature for the initial useFocusTrap hook (#356) enable NoScroll feature for the initial useFocusTrap hook Once you are using Tab and Shift+Tab it does the scrolling. Fixes: #345 update changelog Revert ""Enable NoScroll feature for the initial useFocusTrap hook (#356)"" This reverts commit 19590b07624d7e3d751cbf11de869dfb0ea432ba. Solution is not 100% correct, so will revert for now! Improve search (#385) make search case insensitive for the listbox make search case insensitive for the menu update changelog add disabled prop to RadioGroup and RadioGroup Option (#401) add disabled prop to RadioGroup and RadioGroup Option Also did some general cleanup which in turn fixed an issue where the RadioGroup is unreachable when a value is used that doesn't exist in the list of options. Fixes: #378 update changelog Fix type of RadioGroupOption (#400) Match RadioGroupOption value types to match modelValue allowed types for RadioGroup update changelog fix typo's chore(CI): update main workflow (#395) chore(CI): update main workflow Update main.yml fix dialog event propagation (#422) re-export the screen utility for quick debugging purposes stop event propagation when clicking inside a Dialog Fixes: #414 improve dialog escape (#430) Make sure that Escape only closes the top most Dialog update changelog add defaultOpen prop to Disclosure component (#447) add defaultOpen prop to Disclosure component update changelog Co-authored-by: Shuvro Roy shuvro.roy@northsouth.edu Co-authored-by: Alex Nault nault.alex@gmail.com Co-authored-by: Eugene Kopich github@web2033.com Co-authored-by: Nathan Shoemark n.shoemark@gmail.com Co-authored-by: Michaël De Boey info@michaeldeboey.be"
425,Update 1.bug_report.yml,,Update 1.bug_report.yml,
426,update title validation,,update title validation,
427,Update 1.bug_report.yml,,Update 1.bug_report.yml,
428,link to Headless UI repo,,link to Headless UI repo,
429,Link to docs (#333)," increase maximum error offset for CI tests  We try to detect how long durations took. However there is no nice way to time this in JSDOM. Instead we take snapshots every requestAnimationFrame and when things change we also write down the time. This solution is not ideal and results in false positives (especially on CI environments). However, it is good enough to ensure that the duration is not 0 and not 500.   cleanup README's and link to docs site   remove readme's in favor of doc site   This will be easier, so that we don't have to maintain multiple repo's.",Link to docs (#333),"increase maximum error offset for CI tests We try to detect how long durations took. However there is no nice way to time this in JSDOM. Instead we take snapshots every requestAnimationFrame and when things change we also write down the time. This solution is not ideal and results in false positives (especially on CI environments). However, it is good enough to ensure that the duration is not 0 and not 500. cleanup README's and link to docs site remove readme's in favor of doc site This will be easier, so that we don't have to maintain multiple repo's."
430,bump version to 1.0!,,bump version to 1.0!,
431,provide description in package.json,Also making sure that the README is being published.,provide description in package.json,Also making sure that the README is being published.
432,Merge branch 'develop',,Merge branch 'develop',
433,prepare changelog for release,,prepare changelog for release,
434,Improve transition naming (#331)," rename Transition to TransitionRoot  This will allow us to write it as:  TransitionRoot TransitionChild  This has the added benefit that it doesn't collide with the internal Transition component from Vue itself.  alias Transition.Root to Transition  This allows us to write:  Transition.Root Transition.Child  If you have a standalone Transition, then you can still use  as is.   drop unusued import   update changelog ",Improve transition naming (#331),"rename Transition to TransitionRoot This will allow us to write it as: TransitionRoot TransitionChild This has the added benefit that it doesn't collide with the internal Transition component from Vue itself. alias Transition.Root to Transition This allows us to write: Transition.Root Transition.Child If you have a standalone Transition, then you can still use  as is. drop unusued import update changelog"
435,use passive instead of clickable for Switch label (#332),,use passive instead of clickable for Switch label (#332),
436,Transition component (#326), add redent function when verifying snapshots  This allows us not to care about the correct amount of spaces and always produces a clean output.   make the container the parent of the wrapper element   drop the visible prop on the Portal component   drop visible prop on Portal component   Also cleanup a little bit   expose the RenderStrategy   implement Transition component in Vue   expose Transition component   add Transitions to the Dialog example ,Transition component (#326),add redent function when verifying snapshots This allows us not to care about the correct amount of spaces and always produces a clean output. make the container the parent of the wrapper element drop the visible prop on the Portal component drop visible prop on Portal component Also cleanup a little bit expose the RenderStrategy implement Transition component in Vue expose Transition component add Transitions to the Dialog example
437,Improve Vue dialog (#317),,Improve Vue dialog (#317),
438,add use tree walker hook (#316)," add useTreeWalker hooks  We got a PR to fix the createTreeWalker so that it also works in IE11. We don't actively support IE11, so if things work (with polyfills) then it's good but I don't want to maintain IE11 specific code. That said, I wanted to abstract the createTreeWalker code to a nice little hook. The fix for IE is also pretty small, it uses a function instead of an object and it has a last argument that is deprecated, but has no obvious effect for our use cases. Since the incoming PR was based on the main branch (where we only had 1 reference to createTreeWalker), I wanted to make sure that we got all the references on the latest develop branch. Closes: #295 Co-authored-by: Simon VDB simonvdbroeck@gmail.com  use useTreeWalker hook  Co-authored-by: Simon VDB simonvdbroeck@gmail.com",add use tree walker hook (#316),"add useTreeWalker hooks We got a PR to fix the createTreeWalker so that it also works in IE11. We don't actively support IE11, so if things work (with polyfills) then it's good but I don't want to maintain IE11 specific code. That said, I wanted to abstract the createTreeWalker code to a nice little hook. The fix for IE is also pretty small, it uses a function instead of an object and it has a last argument that is deprecated, but has no obvious effect for our use cases. Since the incoming PR was based on the main branch (where we only had 1 reference to createTreeWalker), I wanted to make sure that we got all the references on the latest develop branch. Closes: #295 Co-authored-by: Simon VDB simonvdbroeck@gmail.com use useTreeWalker hook Co-authored-by: Simon VDB simonvdbroeck@gmail.com"
439,skip the Provider component and simplify context (#315),"I was on a walk, and I realised that in Vue you can just call provide(Symbol, context), which means that a hook like useLabels can just provide context... This simplifies a lot!",skip the Provider component and simplify context (#315),"I was on a walk, and I realised that in Vue you can just call provide(Symbol, context), which means that a hook like useLabels can just provide context... This simplifies a lot!"
440,ensure we forward attributes when using providers,,ensure we forward attributes when using providers,
441,Use internal label and descriptions (#313)," improve internal Label component  We will now add a name to improve error messages, we also introduced a clickable prop on the label. Not 100% happy with the implementation of these internal Label & Description components, but they are internal so we can always change it to something that makes more sense!  improve internal Description component  We will now add a name to improve error messages.   provide the name prop to Description & Label providers   implement the useLabels and useDescriptions in the Switch components   update documentation ",Use internal label and descriptions (#313),"improve internal Label component We will now add a name to improve error messages, we also introduced a clickable prop on the label. Not 100% happy with the implementation of these internal Label & Description components, but they are internal so we can always change it to something that makes more sense! improve internal Description component We will now add a name to improve error messages. provide the name prop to Description & Label providers implement the useLabels and useDescriptions in the Switch components update documentation"
442,cleanup unnecesary dependencies,,cleanup unnecesary dependencies,
443,prevent default event action in keyup (#312),"When we are listening to a keydown event, and when a space event enters. If you then event.preventDefault(), then we still trigger the click event in firefox. To get around this, we have to make sure that we cancel the space event in the keyup event.",prevent default event action in keyup (#312),"When we are listening to a keydown event, and when a space event enters. If you then event.preventDefault(), then we still trigger the click event in firefox. To get around this, we have to make sure that we cancel the space event in the keyup event."
444,fix validation for Vue render function (#310),"We didn't take functional components into account, therefore we would receive errors because a Transition component is a functional component in production and we didn't take that into account.",fix validation for Vue render function (#310),"We didn't take functional components into account, therefore we would receive errors because a Transition component is a functional component in production and we didn't take that into account."
445,ensure we compare raw values (#307),,ensure we compare raw values (#307),
446,Improve error messages (#305),"  small improvement   validate Vue vnode   Also change Fragment to ""template"", oops.  improve error messages in tests for Menu (Vue)  Also actually making sure that we have valid MenuItem components... By default it renders a template, therefore <MenuItem>Abc</MenuItem> is technically incorrect.",Improve error messages (#305),"small improvement validate Vue vnode Also change Fragment to ""template"", oops. improve error messages in tests for Menu (Vue) Also actually making sure that we have valid MenuItem components... By default it renders a template, therefore Abc is technically incorrect."
447,Next batch of Vue components (#282)," add little editor hack  By adding a html.. to the template strings editors can get syntax highlighting for these template strings. Even better, prettier can even format the contents inside those because now it is ""aware"" of what kind of content is inside of these template strings. You might notice that for the Menu component I have a jsx.., this is another little hack, this only provides us with syntax highlighting and not with prettier support. The reason why we have this is that for some reason, when you have: html<MenuItem> It will be formatted as: html<menuitem> There might exist a better name we can use instead of jsx, but for now, this will do. Having syntax highlighting is already 10x better than what we had before!   add Alert component   update changelog   update REACT readme for Alert component   expose Alert component   add Disclosure component   expose Disclosure component   add FocusTrap component   add FocusTrap example   expose FocusTrap   update test utils   We've been making some changes in the React utils, so we have to update them here as well!   add Popover component   expose Popover   drop unused state   type Disclosure's API object   add Portal component   add Portal example   expose Portal component   use correct containElement assertion   add useInertOthers hook   add Dialog component   fix various typo's   expose Dialog   add Popover example   force focus on the Popover button on click   drop own id when using labels   We are nesting the Label and Description components, if we also add the id of ourselves we get strange results when using Voice Over. First you would hear the contents (which includes the labels and descriptions) then you would hear the labels and descriptions again. We don't want to hear things twice!   add Dialog example   ensure to stop propagation   Otherwise if you nest a Menu inside a Dialog and you press Escape the Dialog will close as well, which is not the expected behaviour.  improve focus management  When you trigger a Popover using a click event, then start using Tab the next a-tags do not contain the default focus styles. These only happen when you trigger it using the keyboard first. Using a tabindex=""0"" does make it ""focusable"" and the default browser styles will be visible. If we remove the tabindex in a requestAnimationFrame or a setTimeout then the focus styles will be removed as well. This should not cause to many issues (fingers crossed) because the document.activeElement was already referring to the correct element!  remove Alert component  There are a lot of unknowns and context dependendant questions to implement Alerts in a good way. The current Alert component just had a role set, and it had no JS attached. We will revisit this, once we start working on Alert Dialogs, Notification center notifications (dismissable, hide after x time, ...)   ensure Popover.Overlay auto shows/hides based on Popover state   enable focus trapping based on open prop   Only enable focus trapping in the Dialog when open is true, regardless of the static prop.   handle attrs on Dialog manually   add low level Description component   add low level Label component   add RadioGroup component   expose RadioGroup   update README with links to new components   update changelog with all the changes   add RadioGroup example   improve type in test   cleanup internal Dialog Description   We have a low level Description component abstraction that can be used instead of the Dialog specifiction Description.   refactor raw window events to a shared useWindowEvent   passthrough prop bag via context for abstract Description   The Description component is a generic low level component that is re-used. This causes an issue that the render prop ""bag""/""slot"" doesn't contain the data from let's say a Dialog component. This commit will ensure that you can specify a bag (React) and slot (Vue) on the DescriptionProvider, so that the Description component can read it from the context.  improve render function in React  These contain a few changes that are purely internal changes. Nothing changes / breaks in the public API of the components.  Instead of using multiple arguments in your render() functions, we now use an object. propsBag / bag is renamed to slot.  We also provide a name to the render function, so that we can use   that to improve error messages.   use the new internal render api (React)   improve render function in Vue   use the new internal render api (Vue) ",Next batch of Vue components (#282),"add little editor hack By adding a html.. to the template strings editors can get syntax highlighting for these template strings. Even better, prettier can even format the contents inside those because now it is ""aware"" of what kind of content is inside of these template strings. You might notice that for the Menu component I have a jsx.., this is another little hack, this only provides us with syntax highlighting and not with prettier support. The reason why we have this is that for some reason, when you have: html It will be formatted as: html There might exist a better name we can use instead of jsx, but for now, this will do. Having syntax highlighting is already 10x better than what we had before! add Alert component update changelog update REACT readme for Alert component expose Alert component add Disclosure component expose Disclosure component add FocusTrap component add FocusTrap example expose FocusTrap update test utils We've been making some changes in the React utils, so we have to update them here as well! add Popover component expose Popover drop unused state type Disclosure's API object add Portal component add Portal example expose Portal component use correct containElement assertion add useInertOthers hook add Dialog component fix various typo's expose Dialog add Popover example force focus on the Popover button on click drop own id when using labels We are nesting the Label and Description components, if we also add the id of ourselves we get strange results when using Voice Over. First you would hear the contents (which includes the labels and descriptions) then you would hear the labels and descriptions again. We don't want to hear things twice! add Dialog example ensure to stop propagation Otherwise if you nest a Menu inside a Dialog and you press Escape the Dialog will close as well, which is not the expected behaviour. improve focus management When you trigger a Popover using a click event, then start using Tab the next a-tags do not contain the default focus styles. These only happen when you trigger it using the keyboard first. Using a tabindex=""0"" does make it ""focusable"" and the default browser styles will be visible. If we remove the tabindex in a requestAnimationFrame or a setTimeout then the focus styles will be removed as well. This should not cause to many issues (fingers crossed) because the document.activeElement was already referring to the correct element! remove Alert component There are a lot of unknowns and context dependendant questions to implement Alerts in a good way. The current Alert component just had a role set, and it had no JS attached. We will revisit this, once we start working on Alert Dialogs, Notification center notifications (dismissable, hide after x time, ...) ensure Popover.Overlay auto shows/hides based on Popover state enable focus trapping based on open prop Only enable focus trapping in the Dialog when open is true, regardless of the static prop. handle attrs on Dialog manually add low level Description component add low level Label component add RadioGroup component expose RadioGroup update README with links to new components update changelog with all the changes add RadioGroup example improve type in test cleanup internal Dialog Description We have a low level Description component abstraction that can be used instead of the Dialog specifiction Description. refactor raw window events to a shared useWindowEvent passthrough prop bag via context for abstract Description The Description component is a generic low level component that is re-used. This causes an issue that the render prop ""bag""/""slot"" doesn't contain the data from let's say a Dialog component. This commit will ensure that you can specify a bag (React) and slot (Vue) on the DescriptionProvider, so that the Description component can read it from the context. improve render function in React These contain a few changes that are purely internal changes. Nothing changes / breaks in the public API of the components. Instead of using multiple arguments in your render() functions, we now use an object. propsBag / bag is renamed to slot. We also provide a name to the render function, so that we can use   that to improve error messages. use the new internal render api (React) improve render function in Vue use the new internal render api (Vue)"
448,fix codesandbox examples for Vue (#301),,fix codesandbox examples for Vue (#301),
449,change ensue to ensure,,change ensue to ensure,
450,update changelog,,update changelog,
451,Add Alert & RadioGroup components (#274),"  add Alert component   expose Alert   rename forgotten FLYOUT to POPOVER   use PopoverRenderPropArg   organize imports in a consistent way   ensure Portals behave as expected   Portals can be nested from a React perspective, however in the DOM they are rendered as siblings, this is mostly fine. However, when they are rendered inside a Dialog, the Dialog itself is marked with role=""modal"" which makes all the other content inert. This means that rendering Menu.Items in a Portal or an Alert in a portal makes it non-interactable. Alerts are not even announced. To fix  this, we ensure that we make the root of the Portal the actual dialog. This allows you to still interact with it, because an open modal is the ""root"" for the assistive technology. But there is a catch, a Dialog in a Dialog can render as a sibling, because you force the focus into the new Dialog. So we also ensured that Dialogs are always rendered in the portal root, and not inside another Dialog.   add dialog with alert example   add internal Description component   add internal Label component   add RadioGroup component   expose RadioGroup   add RadioGroup example   ensure to include tha RadioGroup.Option own id   update changelog   split documentation ",Add Alert & RadioGroup components (#274),"add Alert component expose Alert rename forgotten FLYOUT to POPOVER use PopoverRenderPropArg organize imports in a consistent way ensure Portals behave as expected Portals can be nested from a React perspective, however in the DOM they are rendered as siblings, this is mostly fine. However, when they are rendered inside a Dialog, the Dialog itself is marked with role=""modal"" which makes all the other content inert. This means that rendering Menu.Items in a Portal or an Alert in a portal makes it non-interactable. Alerts are not even announced. To fix  this, we ensure that we make the root of the Portal the actual dialog. This allows you to still interact with it, because an open modal is the ""root"" for the assistive technology. But there is a catch, a Dialog in a Dialog can render as a sibling, because you force the focus into the new Dialog. So we also ensured that Dialogs are always rendered in the portal root, and not inside another Dialog. add dialog with alert example add internal Description component add internal Label component add RadioGroup component expose RadioGroup add RadioGroup example ensure to include tha RadioGroup.Option own id update changelog split documentation"
452,fix Portal cleanup issue (#266),"When the last portal is unmounted we will document.body.removeChild(target), but this crashes when something tampered with it. This is reproduceable in the tests. Instead we now ensure that the portal root always exists when mounting. We will also ensure to target.parentElement.removeChild which will ensure that we can reference the parent correctly.",fix Portal cleanup issue (#266),"When the last portal is unmounted we will document.body.removeChild(target), but this crashes when something tampered with it. This is reproduceable in the tests. Instead we now ensure that the portal root always exists when mounting. We will also ensure to target.parentElement.removeChild which will ensure that we can reference the parent correctly."
453,Small cleanup in React Readme (#253),remove unused import in example,Small cleanup in React Readme (#253),remove unused import in example
454,add missing imports,Closes: #255 Co-authored-by: Pier-Luc Gendreau Zertz@users.noreply.github.com,add missing imports,Closes: #255 Co-authored-by: Pier-Luc Gendreau Zertz@users.noreply.github.com
455,bug fixes (#261),"  apply re-focus bug fix to Popover   force focus in Menu.Items from within Menu.Items component itself   force focus in Listbox.Options from within Listbox.Options component itself   fix undefined values in id's   We were setting the element in state, but updates to the id were not taken into account   update the caniuse db   ensure useInertOthers works in multiple places   Previously each hook call would take care of the whole tree. However when multiple calls to this hook are happening we need to make sure that you are not removing the aria-hidden when another hook is still used. This will fix that by keeping track of a list of ""interactable"" items, and updating the parents (root of the body) accordingly.  add the concept of a Stack  When you are rendering a Dialog, we will make sure that this Dialog is rendered inside a Portal. However, when you are also rendering a Menu, there is a chance that your Menu doesn't fit within the Dialog, therefore you will likely render the Menu.Items inside a Portal so that you can style it as if it is rendered inside but overflows the Dialog correctly. This introduces an interesting/annoying problem. Your Menu.Items are now rendered in a Portal, as a sibling to the Dialog. This means that autoFocus, focusTrap, ... all these features don't work as expected. Introducing this Stack will allow us to register DOM nodes into a list of contains that we consider being part of the main container. In other words, the sibling Menu.Items will now be considered part of the Dialog. Even though it is rendered outside of the Dialog. This concept also allows for some fun stuff, for example, nesting Dialog's is no problem with this approach. Dialogs are technically rendered as siblings in the Portal, but the FocusTrap, and all that just works as expected.  capture keyboard events in the capturing phase  This will allow us to use event.stopPropagation() in the code (which will be required, probably) but still see the keystrokes in the playground.  stop propagating keyboard events  This looks a bit silly, and ideally we can solve this in a more elegant way. However when you nest a Menu inside a Dialog, both of those components have a close on escape functionality built in. However when your Menu is open, and you press escape, you only want to close the Menu, not the Dialog. Therefore if we event.stopPropagation() it allows us to stop the escape keystroke in the Menu from reaching all the way to the Dialog itself.   update Dialog example that showcases nested Dialogs, and nested Menu   update changelog ",bug fixes (#261),"apply re-focus bug fix to Popover force focus in Menu.Items from within Menu.Items component itself force focus in Listbox.Options from within Listbox.Options component itself fix undefined values in id's We were setting the element in state, but updates to the id were not taken into account update the caniuse db ensure useInertOthers works in multiple places Previously each hook call would take care of the whole tree. However when multiple calls to this hook are happening we need to make sure that you are not removing the aria-hidden when another hook is still used. This will fix that by keeping track of a list of ""interactable"" items, and updating the parents (root of the body) accordingly. add the concept of a Stack When you are rendering a Dialog, we will make sure that this Dialog is rendered inside a Portal. However, when you are also rendering a Menu, there is a chance that your Menu doesn't fit within the Dialog, therefore you will likely render the Menu.Items inside a Portal so that you can style it as if it is rendered inside but overflows the Dialog correctly. This introduces an interesting/annoying problem. Your Menu.Items are now rendered in a Portal, as a sibling to the Dialog. This means that autoFocus, focusTrap, ... all these features don't work as expected. Introducing this Stack will allow us to register DOM nodes into a list of contains that we consider being part of the main container. In other words, the sibling Menu.Items will now be considered part of the Dialog. Even though it is rendered outside of the Dialog. This concept also allows for some fun stuff, for example, nesting Dialog's is no problem with this approach. Dialogs are technically rendered as siblings in the Portal, but the FocusTrap, and all that just works as expected. capture keyboard events in the capturing phase This will allow us to use event.stopPropagation() in the code (which will be required, probably) but still see the keystrokes in the playground. stop propagating keyboard events This looks a bit silly, and ideally we can solve this in a more elegant way. However when you nest a Menu inside a Dialog, both of those components have a close on escape functionality built in. However when your Menu is open, and you press escape, you only want to close the Menu, not the Dialog. Therefore if we event.stopPropagation() it allows us to stop the escape keystroke in the Menu from reaching all the way to the Dialog itself. update Dialog example that showcases nested Dialogs, and nested Menu update changelog"
456,Class name functions (#257), allow className to be a function  Every component that accepts a className should be able to pass in a function. This function will retrieve the render prop arg for this component. The function should resolve to a string in the end. This makes the API a bit nicer if you just need to change the classNames based on some internal state. E.g.: ```js // Before    {({ open }) => (            Hello        )}  // After  open ? 'font-bold' : 'font-normal'}>   Hello  ```   cleanup types   merge React imports   update changelog ,Class name functions (#257),allow className to be a function Every component that accepts a className should be able to pass in a function. This function will retrieve the render prop arg for this component. The function should resolve to a string in the end. This makes the API a bit nicer if you just need to change the classNames based on some internal state. E.g.: ```js // Before {({ open }) => ( module )} // After  open ? 'font-bold' : 'font-normal'}>   Hello ``` cleanup types merge React imports update changelog
457,Fix refocus button bug (#256)," fix outside click on span inside button works as expected  We have outside click behaviour implemented. Whenever the target element is focusable we make sure that the newly clicked/focused element stays focused. If it is not a focusable element we will make sure that the Menu/Listbox button is re-focused so that screenreader users don't get confused. This is all fine, but it turns out that when you have a button with a span, and you click on the span, then the event.target will be that span. The span itself is not focusable of course, but the button will get the focus. This results in the Menu/Listbox button being re-focused which is incorrect. For this we will introduce a FocusableMode on the isFocusableElement, we will have a Strict mode, which means the actual element should be focusable. And a Loose mode, which means that the actual element can be inside a focusable element. E.g.: A span within a button.  rename menu to listbox  Copy paste can be fun sometimes  update changelog",Fix refocus button bug (#256),"fix outside click on span inside button works as expected We have outside click behaviour implemented. Whenever the target element is focusable we make sure that the newly clicked/focused element stays focused. If it is not a focusable element we will make sure that the Menu/Listbox button is re-focused so that screenreader users don't get confused. This is all fine, but it turns out that when you have a button with a span, and you click on the span, then the event.target will be that span. The span itself is not focusable of course, but the button will get the focus. This results in the Menu/Listbox button being re-focused which is incorrect. For this we will introduce a FocusableMode on the isFocusableElement, we will have a Strict mode, which means the actual element should be focusable. And a Loose mode, which means that the actual element can be inside a focusable element. E.g.: A span within a button. rename menu to listbox Copy paste can be fun sometimes update changelog"
458,Fix ref element (#249),"  add small dom utility to resolve the dom node from a ref   use dom() to resolve underlying DOM node   There is probably a better way to do this, the idea is that we apply a ref to the component. However by default for html components yourRef.value will be the underlying DOM node. However if you pass the ref to another component, the actual DOM node will be located at yourRef.value.$el. Fixes: #21  update changelog",Fix ref element (#249),"add small dom utility to resolve the dom node from a ref use dom() to resolve underlying DOM node There is probably a better way to do this, the idea is that we apply a ref to the component. However by default for html components yourRef.value will be the underlying DOM node. However if you pass the ref to another component, the actual DOM node will be located at yourRef.value.$el. Fixes: #21 update changelog"
459,Fix unique symbol error (#248)," replace unique symbol with uuid v4  Ideally we can use a Symbol, however it seems that TypeScript or TSDX, inlines the unique symbol, instead of referencing the actual __ placeholder type. Ideally we add this back in the future, but the odds that somebody has this specific uuid in production is close to 0. (Unless they specifically use this uuid). Fixes: #240 Thanks to =?UTF-8?q?Micha=C3=ABl=20Zasso?= targos@protonmail.com for providing a reproduction repository!  update changelog",Fix unique symbol error (#248),"replace unique symbol with uuid v4 Ideally we can use a Symbol, however it seems that TypeScript or TSDX, inlines the unique symbol, instead of referencing the actual __ placeholder type. Ideally we add this back in the future, but the odds that somebody has this specific uuid in production is close to 0. (Unless they specifically use this uuid). Fixes: #240 Thanks to =?UTF-8?q?Micha=C3=ABl=20Zasso?= targos@protonmail.com for providing a reproduction repository! update changelog"
460,assign displayName instead of name (#247),"This allows us to read a custom displayName, and we can default to a name. React Devtools will still be able to read this information. Fixes: #246",assign displayName instead of name (#247),"This allows us to read a custom displayName, and we can default to a name. React Devtools will still be able to read this information. Fixes: #246"
461,"Added new examples for switch components (React, Vue) (#245)",  Added new example for switch component (React)   Added new example for switch component (Vue) ,"Added new examples for switch components (React, Vue) (#245)",Added new example for switch component (React) Added new example for switch component (Vue)
462,prevent unnecessary re-renders when the state is already correct,,prevent unnecessary re-renders when the state is already correct,
463,update changelog,,update changelog,
464,Multiple new components (#220),"  add Disclosure component   expose the Disclosure component   add Disclosure example component page   temporary fix selector because of JSDOM bug   add useFocusTrap hook   add FocusTrap component   expose FocusTrap   add Dialog component   add Dialog example component page   expose Dialog   random cleanup   make TypeScript a bit more happy   add Switch.Description component for React   add Switch.Description component for Vue   ensure focus event is triggered on click when element is focusable   remove Dialog.Button and Dialog.Panel from accessibility assertions   add Portal component   expose Portal   always render Dialog in a Portal   add useInertOthers hook   This will allow us to mark everything but the current ref as ""inert"". This is important for screenreaders, to ensure that screenreaders and assistive technology can't interact with other content but the current ref. This implementation is not ideal yet. It doesn't take into account that you can use the hook in 2 different components. For now this is fine, since we only use it in a Dialog and you should also probably only have a single Dialog open at a time. Will improve this in the future!   use the useInertOthers hook   add scroll lock to the dialog   ensure we respect autoFocus on form elements within the Dialog   If we have an autoFocus on an input, that input will receive focus. Once we try to focus the first focusable element in the Dialog this could be lead to unwanted behaviour. Therefore we check if the focus already is within the Dialog, if it is, keep it like that.   only mark aria-modal when Dialog is open   add initialFocus option to Dialog, FocusTrap & useFocusTrap   add tests and a few fixes for the initialFocusRef functionality   forward ref to underlying Dialog component   close Dialog when it becomes hidden   Could happen when this is in md:hidden for example  prevent infinite loop  When we Tab in a FocusTrap it will try and focus the Next element. If we are in a state where none of the elements inside the FocusTrap can be focused, then we keep trying to focus the next one in line. This results in an infinite loop... To mitigate this issue, we check if we looped around, if we did, it means that we tried all the other focusable elements, therefore we can stop.  isIntersecting doesn't work in every scenario  When page is scrollable, when dialog is translated of the page. Now just checking for sizes, which should be enough for md:hiden cases  render Portal contents in a div  Otherwise you can't use multiple Portal components if you render multiple children inside each Portal   ensure the props bag is typed   add getByText and assertContainsActiveElement helpers   add Popover component   expose Popover   add Popover example component page   add quick checks to prevent useless renders   drop incorrect close function   update Changelog   make test error more readable when comparing DOM nodes   actually call .focus() on the element   This ensures that the document.activeElement becomes the focused element.   improve useSyncRefs, because ...refs is always different   add dedicated focus management utilities   refactor useFocusTrap, use focus management utilities   fix regression while using outside click   There might be a chance that you didn't even notice this bug. The idea is that when you click outside, that the Menu or Listbox closes. However there is another step that happens:  When you click on a focusable item, keep the focus on that item. When you click on a non-focusable item, move focus back to the    Menu.Button or Listbox.Button  We broke part 2, we never returned to the Menu.Button or Listbox.Button. This is (might) be important for screenreaders so that they don't ""get lost"", because if you click on a non-focusable item, the document.body becomes the active element. Confusing.   add outside-click to Dialog itself   update docs ",Multiple new components (#220),"add Disclosure component expose the Disclosure component add Disclosure example component page temporary fix selector because of JSDOM bug add useFocusTrap hook add FocusTrap component expose FocusTrap add Dialog component add Dialog example component page expose Dialog random cleanup make TypeScript a bit more happy add Switch.Description component for React add Switch.Description component for Vue ensure focus event is triggered on click when element is focusable remove Dialog.Button and Dialog.Panel from accessibility assertions add Portal component expose Portal always render Dialog in a Portal add useInertOthers hook This will allow us to mark everything but the current ref as ""inert"". This is important for screenreaders, to ensure that screenreaders and assistive technology can't interact with other content but the current ref. This implementation is not ideal yet. It doesn't take into account that you can use the hook in 2 different components. For now this is fine, since we only use it in a Dialog and you should also probably only have a single Dialog open at a time. Will improve this in the future! use the useInertOthers hook add scroll lock to the dialog ensure we respect autoFocus on form elements within the Dialog If we have an autoFocus on an input, that input will receive focus. Once we try to focus the first focusable element in the Dialog this could be lead to unwanted behaviour. Therefore we check if the focus already is within the Dialog, if it is, keep it like that. only mark aria-modal when Dialog is open add initialFocus option to Dialog, FocusTrap & useFocusTrap add tests and a few fixes for the initialFocusRef functionality forward ref to underlying Dialog component close Dialog when it becomes hidden Could happen when this is in md:hidden for example prevent infinite loop When we Tab in a FocusTrap it will try and focus the Next element. If we are in a state where none of the elements inside the FocusTrap can be focused, then we keep trying to focus the next one in line. This results in an infinite loop... To mitigate this issue, we check if we looped around, if we did, it means that we tried all the other focusable elements, therefore we can stop. isIntersecting doesn't work in every scenario When page is scrollable, when dialog is translated of the page. Now just checking for sizes, which should be enough for md:hiden cases render Portal contents in a div Otherwise you can't use multiple Portal components if you render multiple children inside each Portal ensure the props bag is typed add getByText and assertContainsActiveElement helpers add Popover component expose Popover add Popover example component page add quick checks to prevent useless renders drop incorrect close function update Changelog make test error more readable when comparing DOM nodes actually call .focus() on the element This ensures that the document.activeElement becomes the focused element. improve useSyncRefs, because ...refs is always different add dedicated focus management utilities refactor useFocusTrap, use focus management utilities fix regression while using outside click There might be a chance that you didn't even notice this bug. The idea is that when you click outside, that the Menu or Listbox closes. However there is another step that happens: When you click on a focusable item, keep the focus on that item. When you click on a non-focusable item, move focus back to the    Menu.Button or Listbox.Button We broke part 2, we never returned to the Menu.Button or Listbox.Button. This is (might) be important for screenreaders so that they don't ""get lost"", because if you click on a non-focusable item, the document.body becomes the active element. Confusing. add outside-click to Dialog itself update docs"
465,fix codesandbox examples for Vue (#300),,fix codesandbox examples for Vue (#300),
466,bump versions,,bump versions,
467,update CHANGELOG,,update CHANGELOG,
468,backfill fixes (#299),"  fix unique symbol error (#248)   Vue breaking change (#279)   bump Vue   ensure we reference the vite.config.js   fix event name casing   Vue broke this in a 3.0.5 release, it still worked in 3.0.4. Fixes: #267  handle throwing while rendering a better in tests",backfill fixes (#299),"fix unique symbol error (#248) Vue breaking change (#279) bump Vue ensure we reference the vite.config.js fix event name casing Vue broke this in a 3.0.5 release, it still worked in 3.0.4. Fixes: #267 handle throwing while rendering a better in tests"
469,fix github templates,,fix github templates,
470,Move ISSUE_TEMPLATE config to the right directory (#288),,Move ISSUE_TEMPLATE config to the right directory (#288),
471,Add bug report issue template + issue hub YAML configs (#287), Add ISSUE_TEMPLATE config Add bug report template config,Add bug report issue template + issue hub YAML configs (#287),Add ISSUE_TEMPLATE config Add bug report template config
472,change links from develop to main branch,,change links from develop to main branch,
473,bump version,,bump version,
474,update changlog for React 0.3.1 version,,update changlog for React 0.3.1 version,
475,0.0.2,,0.0.2,
476,update changelog,,update changelog,
477,correctly handle TypeScript render abstractions,,correctly handle TypeScript render abstractions,
478,ensure correct path to types,,ensure correct path to types,
479,move Transition changes to a changes section,,move Transition changes to a changes section,
480,v0.3.0,,v0.3.0,
481,update changelog,,update changelog,
482,add changelog (#232),  update docs   add CHANGELOG ,add changelog (#232),update docs add CHANGELOG
483,Add disabled to listbox (#229),  allow to press on an element without focusing it first   add disabled option to the Listbox component ,Add disabled to listbox (#229),allow to press on an element without focusing it first add disabled option to the Listbox component
484,ensure valid Menu accessibility tree (#228),,ensure valid Menu accessibility tree (#228),
485,add better implementation to detect the FPS,,add better implementation to detect the FPS,
486,ensure the active MenuItem is scrolled into view,Fixes: #227,ensure the active MenuItem is scrolled into view,Fixes: #227
487,drop dependabot,,drop dependabot,
488,cleanup and consistency (#213)," Made the use of const and let consistent import required functions and types from 'react' instead of using the   React. namespace. Added Expand type, which can expand complex types to their ""final""   result. Ensured that we use as const for DEFAULT_XXX_TAG where we used a   string. So that we have the type of div instead of string for   example. Used interface over type where possible. I'm personally more of a   type fan. But the TypeScript recommends interfaces where possible   because they are faster, yield better error messages and so on.",cleanup and consistency (#213),"Made the use of const and let consistent import required functions and types from 'react' instead of using the   React. namespace. Added Expand type, which can expand complex types to their ""final""   result. Ensured that we use as const for DEFAULT_XXX_TAG where we used a   string. So that we have the type of div instead of string for   example. Used interface over type where possible. I'm personally more of a   type fan. But the TypeScript recommends interfaces where possible   because they are faster, yield better error messages and so on."
489,"trigger ""outside click"" behaviour on mousedown (#212)",Fixes: #95,"trigger ""outside click"" behaviour on mousedown (#212)",Fixes: #95
490,Fix various event bugs (#211),"  add right click option to the interactions   add tests to ensure right click behaves as expected   Fixes: #142 Fixes: #167  fallback to mouse events if pointer events are not supported  When the pointer events are not supported, then this is essentially a no-op. When they are supported, then both the pointer and mouse events will fire. To mitigate potential issues, we make sure that state changes (and potential re-renders) are idempotent (we bail out on potential state updates when we are already ina certain state). Fixes: #173 Fixes: #167",Fix various event bugs (#211),"add right click option to the interactions add tests to ensure right click behaves as expected Fixes: #142 Fixes: #167 fallback to mouse events if pointer events are not supported When the pointer events are not supported, then this is essentially a no-op. When they are supported, then both the pointer and mouse events will fire. To mitigate potential issues, we make sure that state changes (and potential re-renders) are idempotent (we bail out on potential state updates when we are already ina certain state). Fixes: #173 Fixes: #167"
491,bump dependencies (#177),  bump root dependencies   bump react related dependencies   update browserslist db   remove obsolete shared dependency ,bump dependencies (#177),bump root dependencies bump react related dependencies update browserslist db remove obsolete shared dependency
492,handle keyboard interactions in a more robust way,"Browsers. Are. Crazy. In JSDOM, when you fire an event, you only get that specific event. You don't get all the magic that the browser gives you. For example, when you are focused on a button and press to ""Tab"" then in JSDOM you would only get a keydown event. However in the browser you get this chain of events:  keydown on the current element blur on the current element focus on the new element keyup on the new element  I implemented this ""magic"", for the Tab, Enter and Space key for now. Those are the most important currently. Enter and Space also trigger click events for example. I also have a ""generic"" implementation, where a normal press results in:  keydown keypress (in case it has a charCode and is ""printable"", so alt    is ignored) keyup  I also ensured that the cancelation when you use an event.preventDefault() happens correctly. Here is a fun summary: https://twitter.com/malfaitrobin/status/1354472678128820234 Press ""Enter"" on a button   -> keydown, keypress, click, keyup Press ""Space"" on a button   -> keydown, keypress, keyup, click Press ""Enter"" or ""Space"" on a button, with event.preventDefault() in the keydown listener   -> keydown, keyup Press ""Enter"" on a button, with event.preventDefault() in the keypress listener   -> keydown, keypress, keyup Press ""Space"" on a button, with event.preventDefault() in the keypress listener   -> keydown, keypress, keyup, click",handle keyboard interactions in a more robust way,"Browsers. Are. Crazy. In JSDOM, when you fire an event, you only get that specific event. You don't get all the magic that the browser gives you. For example, when you are focused on a button and press to ""Tab"" then in JSDOM you would only get a keydown event. However in the browser you get this chain of events: keydown on the current element blur on the current element focus on the new element keyup on the new element I implemented this ""magic"", for the Tab, Enter and Space key for now. Those are the most important currently. Enter and Space also trigger click events for example. I also have a ""generic"" implementation, where a normal press results in: keydown keypress (in case it has a charCode and is ""printable"", so alt    is ignored) keyup I also ensured that the cancelation when you use an event.preventDefault() happens correctly. Here is a fun summary: link Press ""Enter"" on a button   -> keydown, keypress, click, keyup Press ""Space"" on a button   -> keydown, keypress, keyup, click Press ""Enter"" or ""Space"" on a button, with event.preventDefault() in the keydown listener   -> keydown, keyup Press ""Enter"" on a button, with event.preventDefault() in the keypress listener   -> keydown, keypress, keyup Press ""Space"" on a button, with event.preventDefault() in the keypress listener   -> keydown, keypress, keyup, click"
493,ensure that we regenerate the id when it is still null,,ensure that we regenerate the id when it is still null,
494,update React Transition docs (#203),,update React Transition docs (#203),
495,apply disabled fix when inside a disabled fieldset (#202),"And if we are in a disabled fieldset, double check that we are not in the first legend. Because in that case we are visually outside of the fieldset and according to the spec those elements should not be considered disabled. Fixes: #194",apply disabled fix when inside a disabled fieldset (#202),"And if we are in a disabled fieldset, double check that we are not in the first legend. Because in that case we are visually outside of the fieldset and according to the spec those elements should not be considered disabled. Fixes: #194"
496,fix: added emits property to Vue components (#199),,fix: added emits property to Vue components (#199),
497,"ensure Switch has type=""button"" (#192)",Closes: #178 Co-authored-by: =?UTF-8?q?Oskar=20L=C3=B6fgren?= islander.abroad@gmail.com Co-authored-by: =?UTF-8?q?Oskar=20L=C3=B6fgren?= islander.abroad@gmail.com,"ensure Switch has type=""button"" (#192)",Closes: #178 Co-authored-by: =?UTF-8?q?Oskar=20L=C3=B6fgren?= islander.abroad@gmail.com Co-authored-by: =?UTF-8?q?Oskar=20L=C3=B6fgren?= islander.abroad@gmail.com
498,docs: Fix links (#183),,docs: Fix links (#183),
499,docs: rename class to className (#139),,docs: rename class to className (#139),
500,Add displayName to all contexts in react (#175),,Add displayName to all contexts in react (#175),
501,prevent scrolling when refocusing items,Fixes #161,prevent scrolling when refocusing items,Fixes #161
502,allow Number and Boolean types for Vue Listboxes,In React we already use a generic. Maybe we can do this in a more generic way for Vue in the future.,allow Number and Boolean types for Vue Listboxes,In React we already use a generic. Maybe we can do this in a more generic way for Vue in the future.
503,remove unused d dependency,,remove unused d dependency,
504,fix: outside click refocus bug (#114),"  add watch script   make interactions in Vue and React consistent   re-work focus restoration   When we click outside of the Menu or Listbox, we want to restore the focus to the Button, unless we clicked on/in an element that is focusable in itself. For example, when the Menu is open and you click in an input field, the input field should stay focused. We should also close the Menu itself at this point.   add examples with multiple elements   bump dependencies ",fix: outside click refocus bug (#114),"add watch script make interactions in Vue and React consistent re-work focus restoration When we click outside of the Menu or Listbox, we want to restore the focus to the Button, unless we clicked on/in an element that is focusable in itself. For example, when the Menu is open and you click in an input field, the input field should stay focused. We should also close the Menu itself at this point. add examples with multiple elements bump dependencies"
505,chore: Cleanup duplication (#109),  remove duplicate calculate-active-index calculation   make codebase a bit more consistent   remove duplicate resolve-prop-value ,chore: Cleanup duplication (#109),remove duplicate calculate-active-index calculation make codebase a bit more consistent remove duplicate resolve-prop-value
506,feat: add render features + render strategy (#106),"  add unmount strategy to README (React)   add unmount strategy to README (Vue)   add different render features (React)   use render features in Menu and Listbox (React)   add different render features (Vue)   use render features in Menu and Listbox (Vue)   bump dependencies   add ability to change the ref property using refName   Example use case: ``tsx // Some components have this API with aninnerRef. The suggested approach is to use //React.forwardRefso that you get the actualrefvalue. However if you already have this //innerRefAPI than we can use therefName=""innerRef""to give therefprop a good name. It // defaults toref` so that it still works everywhere else. function MyButton({ innerRef, ...props }) {   return  }  ```   small cleanup, move refs to props we control   add tests for the render abstraction (Render)   use the unique __ symbol as a default value in the Props type for the   omitable props.   use render features in Transition (React)   add/update Transition examples to also showcase the unmount={false} render strategy   bump dependencies   add example with nested unmount/hide transitions   add unmount to Transition documentation ",feat: add render features + render strategy (#106),"add unmount strategy to README (React) add unmount strategy to README (Vue) add different render features (React) use render features in Menu and Listbox (React) add different render features (Vue) use render features in Menu and Listbox (Vue) bump dependencies add ability to change the ref property using refName Example use case: module so that it still works everywhere else. function MyButton({ innerRef, ...props }) {   return  } ``` small cleanup, move refs to props we control add tests for the render abstraction (Render) use the unique __ symbol as a default value in the Props type for the   omitable props. use render features in Transition (React) add/update Transition examples to also showcase the unmount={false} render strategy bump dependencies add example with nested unmount/hide transitions add unmount to Transition documentation"
507,chore: bump dependencies (#100),,chore: bump dependencies (#100),
508,docs: improve documentation (#91),  format README's with Prettier   hoist people list   otherwise the reference will never be the same when you select a new item. Alternative could be to put it in a ref or useMemo or something.  make whitespace consistent,docs: improve documentation (#91),format README's with Prettier hoist people list otherwise the reference will never be the same when you select a new item. Alternative could be to put it in a ref or useMemo or something. make whitespace consistent
509,chore: bump dependencies (#90),,chore: bump dependencies (#90),
510,bump dependencies,,bump dependencies,
511,feat: Add Transition events (#57),  fix wrong class in tests   add Transition event callbacks   add Transition Modal example with Event callbacks   update props table of Transition component ,feat: Add Transition events (#57),fix wrong class in tests add Transition event callbacks add Transition Modal example with Event callbacks update props table of Transition component
512,fix Listbox.Option value typing,,fix Listbox.Option value typing,
513,docs: fix variable name in README (#71),Looks like an old variable that hasn't been renamed,docs: fix variable name in README (#71),Looks like an old variable that hasn't been renamed
514,chore: bump dependencies (#70), drop jest related dependencies  These are already included via tsdx  bump dependencies,chore: bump dependencies (#70),drop jest related dependencies These are already included via tsdx bump dependencies
515,docs: Vue component names not dot-separated (#61),,docs: Vue component names not dot-separated (#61),
516,fix: allow disabling the Menu/Listbox button (#56),  make sure the Menu.Button can be disabled (React)   make sure the MenuButton can be disabled (Vue)   make sure the Listbox.Button can be disabled (React)   make sure the ListboxButton can be disabled (Vue) ,fix: allow disabling the Menu/Listbox button (#56),make sure the Menu.Button can be disabled (React) make sure the MenuButton can be disabled (Vue) make sure the Listbox.Button can be disabled (React) make sure the ListboxButton can be disabled (Vue)
517,"cleanup hacky watchEffect, use watch instead",,"cleanup hacky watchEffect, use watch instead",
518,ensure that you can't use Enter to invoke the Switch,And a bunch of keyPress and keyboard related shenanigans,ensure that you can't use Enter to invoke the Switch,And a bunch of keyPress and keyboard related shenanigans
519,chore: bump dependencies,,chore: bump dependencies,
520,docs: Update table of contents and fix code snippet of Listbox (#50),,docs: Update table of contents and fix code snippet of Listbox (#50),
521,docs: Fix code snippet language,,docs: Fix code snippet language,
522,v0.2.0,,v0.2.0,
523,docs: Update table of contents and other navigation,,docs: Update table of contents and other navigation,
524,docs: Add switch documentation,,docs: Add switch documentation,
525,docs: Fix mistake in docs,,docs: Fix mistake in docs,
526,docs: Update Listbox documentation for React and a bit of Vue,,docs: Update Listbox documentation for React and a bit of Vue,
527,docs: Update Vue Listbox docs,,docs: Update Vue Listbox docs,
528,docs: Update Codesandbox links for Listbox components,,docs: Update Codesandbox links for Listbox components,
529,Listbox documentation (#28),  run prettier on README   add Listbox documentation ,Listbox documentation (#28),run prettier on README add Listbox documentation
530,ensure options in listbox can be objects,,ensure options in listbox can be objects,
531,fix: button focus management (#47),  make sure the Button is focused when the Menu closes (React)   make sure the Button is focused when the Menu closes (Vue)   make sure the Button is focused when the Listbox closes (React)   make sure the Button is focused when the Listbox closes (Vue) ,fix: button focus management (#47),make sure the Button is focused when the Menu closes (React) make sure the Button is focused when the Menu closes (Vue) make sure the Button is focused when the Listbox closes (React) make sure the Button is focused when the Listbox closes (Vue)
532,feat: add Switch component (#26),  add Switch component   add tests to verify that we can click the label to toggle the Switch   use onKeyUp to prevent triggering the onClick in firefox ,feat: add Switch component (#26),add Switch component add tests to verify that we can click the label to toggle the Switch use onKeyUp to prevent triggering the onClick in firefox
533,fix: cleanup transition component (#45),Fixes: #25,fix: cleanup transition component (#45),Fixes: #25
534,cleanup yarn.lock file,,cleanup yarn.lock file,
535,chore: Bump framer-motion from 2.7.6 to 2.7.7 (#42),Bumps framer-motion from 2.7.6 to 2.7.7. - Release notes - Changelog - Commits Signed-off-by: dependabot[bot] support@github.com Co-authored-by: dependabot[bot] 49699333+dependabot[bot]@users.noreply.github.com,chore: Bump framer-motion from 2.7.6 to 2.7.7 (#42),Bumps framer-motion from 2.7.6 to 2.7.7. - Release notes - Changelog - Commits Signed-off-by: dependabot[bot] support@github.com Co-authored-by: dependabot[bot] 49699333+dependabot[bot]@users.noreply.github.com
536,chore: Bump @types/react from 16.9.49 to 16.9.50 (#43),Bumps @types/react from 16.9.49 to 16.9.50. - Release notes - Commits Signed-off-by: dependabot[bot] support@github.com Co-authored-by: dependabot[bot] 49699333+dependabot[bot]@users.noreply.github.com,chore: Bump @types/react from 16.9.49 to 16.9.50 (#43),Bumps @types/react from 16.9.49 to 16.9.50. - Release notes - Commits Signed-off-by: dependabot[bot] support@github.com Co-authored-by: dependabot[bot] 49699333+dependabot[bot]@users.noreply.github.com
537,chore: Bump @vue/compiler-sfc from 3.0.0-rc.13 to 3.0.0 (#37),Bumps @vue/compiler-sfc from 3.0.0-rc.13 to 3.0.0. - Release notes - Changelog - Commits Signed-off-by: dependabot[bot] support@github.com Co-authored-by: dependabot[bot] 49699333+dependabot[bot]@users.noreply.github.com,chore: Bump @vue/compiler-sfc from 3.0.0-rc.13 to 3.0.0 (#37),Bumps @vue/compiler-sfc from 3.0.0-rc.13 to 3.0.0. - Release notes - Changelog - Commits Signed-off-by: dependabot[bot] support@github.com Co-authored-by: dependabot[bot] 49699333+dependabot[bot]@users.noreply.github.com
538,chore: Bump babel-jest from 26.3.0 to 26.5.0 (#39),Bumps babel-jest from 26.3.0 to 26.5.0. - Release notes - Changelog - Commits Signed-off-by: dependabot[bot] support@github.com Co-authored-by: dependabot[bot] 49699333+dependabot[bot]@users.noreply.github.com,chore: Bump babel-jest from 26.3.0 to 26.5.0 (#39),Bumps babel-jest from 26.3.0 to 26.5.0. - Release notes - Changelog - Commits Signed-off-by: dependabot[bot] support@github.com Co-authored-by: dependabot[bot] 49699333+dependabot[bot]@users.noreply.github.com
539,chore: Bump jest from 26.4.2 to 26.5.0 (#40),Bumps jest from 26.4.2 to 26.5.0. - Release notes - Changelog - Commits Signed-off-by: dependabot[bot] support@github.com Co-authored-by: dependabot[bot] 49699333+dependabot[bot]@users.noreply.github.com,chore: Bump jest from 26.4.2 to 26.5.0 (#40),Bumps jest from 26.4.2 to 26.5.0. - Release notes - Changelog - Commits Signed-off-by: dependabot[bot] support@github.com Co-authored-by: dependabot[bot] 49699333+dependabot[bot]@users.noreply.github.com
540,chore: use Dependabot to check for npm updates (#23),Dependabot will check for npm updates each working day (Monday trough Friday). It will label any pull requests with the dependencies label.,chore: use Dependabot to check for npm updates (#23),Dependabot will check for npm updates each working day (Monday trough Friday). It will label any pull requests with the dependencies label.
541,simplify lint pre-commit hook,,simplify lint pre-commit hook,
542,docs: fix typo (#29),,docs: fix typo (#29),
543,update branding,Replace Tailwind UI with Headless UI,update branding,Replace Tailwind UI with Headless UI
544,feat: add Listbox component (#3),"  make jest monorepo aware   add @testing-library/jest-dom for custom matchers   This way we can use expect(element).toHaveAttribute(key, value?)   abstract keys enum   change type to unknown, because we don't know the return value   update use-id hook, make it suspense aware   Thanks Reach UI!   hoist the disposables collection   add accessbility assertions for listbox   Also made it consistent for the Menu component and simplified some of the assertions  add use-computed hook  This allows us re-render when hooks change, but also return a value. So this is a combination of useEffect and a useState value.   add Listbox component   bump dependencies   add listbox example   add lint-staged   This way we will only lint the files that have been staged and ready to be committed instead of the whole codebase   add missing prevent defaults   improve tests to verify that we can actually update the value of the listbox   scroll the active listbox item into view   small optimization, only focus ""Nothing"" on pointer leave when we are the active item   We used to always go to ""Nothing"" on pointer leave. And while this code doesn't get called often, it gets called if you are using your arrow keys and the mouse pointer is still over the list.  bump dependencies  Also moved the tailwind dependencies to the root   fix typo   drop the default Transition inside the Menu and Listbox components   update examples to reflect drop of default Transition wrapper   rename Listbox.{Items,Item} to Listbox.{Options,Option}   Also rename all instances of item to option in tests and comments and what have you...   fix typo   drop disabled prop, use aria-disabled only ",feat: add Listbox component (#3),"make jest monorepo aware add @testing-library/jest-dom for custom matchers This way we can use expect(element).toHaveAttribute(key, value?) abstract keys enum change type to unknown, because we don't know the return value update use-id hook, make it suspense aware Thanks Reach UI! hoist the disposables collection add accessbility assertions for listbox Also made it consistent for the Menu component and simplified some of the assertions add use-computed hook This allows us re-render when hooks change, but also return a value. So this is a combination of useEffect and a useState value. add Listbox component bump dependencies add listbox example add lint-staged This way we will only lint the files that have been staged and ready to be committed instead of the whole codebase add missing prevent defaults improve tests to verify that we can actually update the value of the listbox scroll the active listbox item into view small optimization, only focus ""Nothing"" on pointer leave when we are the active item We used to always go to ""Nothing"" on pointer leave. And while this code doesn't get called often, it gets called if you are using your arrow keys and the mouse pointer is still over the list. bump dependencies Also moved the tailwind dependencies to the root fix typo drop the default Transition inside the Menu and Listbox components update examples to reflect drop of default Transition wrapper rename Listbox.{Items,Item} to Listbox.{Options,Option} Also rename all instances of item to option in tests and comments and what have you... fix typo drop disabled prop, use aria-disabled only"
545,docs: fix typo in React README (#22),,docs: fix typo in React README (#22),
546,add basic README,,add basic README,
547,mark fallthrough as expected,,mark fallthrough as expected,
548,implement type ahead mode on Menu,"This will allow us to do 2 things:  When we are in ""type ahead"" mode, aka search, we can use spaces to   search. E.g.: ""Account Settings"" (notice the space) When we are not in ""type ahead"" mode, we can use Space to invoke the   menu item. We used to only allow Enter and Click.",implement type ahead mode on Menu,"This will allow us to do 2 things: When we are in ""type ahead"" mode, aka search, we can use spaces to   search. E.g.: ""Account Settings"" (notice the space) When we are not in ""type ahead"" mode, we can use Space to invoke the   menu item. We used to only allow Enter and Click."
549,be consistent with pointer/mouse events,,be consistent with pointer/mouse events,
550,simplify the click / pointer up handling on Menu Item,Thank you @MartinMa for pointing this complexity out!,simplify the click / pointer up handling on Menu Item,Thank you @MartinMa for pointing this complexity out!
551,version 0.1.3,,version 0.1.3,
552,ensure to prevent the default behaviour of keyboard navigation,,ensure to prevent the default behaviour of keyboard navigation,
553,fix: outside click behaviour (#19),"  add failing tests to prove the outside-click issue   fix outside click when we have multiple menu's   We removed the toggleMenu since we only used it in a single spot,   and had to do some side effect logic (focus & event.preventDefault).   Wanted to make this consistent between React and Vue.  If, in the ""outside click"" logic we detect that we clicked on the   button, we also ignore it. If, we click on the button we will toggle the menu.  Fixes: #18",fix: outside click behaviour (#19),"add failing tests to prove the outside-click issue fix outside click when we have multiple menu's We removed the toggleMenu since we only used it in a single spot,   and had to do some side effect logic (focus & event.preventDefault).   Wanted to make this consistent between React and Vue. If, in the ""outside click"" logic we detect that we clicked on the   button, we also ignore it. If, we click on the button we will toggle the menu. Fixes: #18"
554,ensure that anchor links are still clickable,"This is an issue in the Vue version (it just works in the React version) but I added tests for them anyway. While this solution ""works"" I am not 100% happy with it. Let me explain what's happening here and why I am not that happy about it:  For starters, the Vue nextTick is apparently too fast. So what we do   is when we get the pointer up event, we will close the menu and   re-focus the button. We ran this code in a nextTick so that we can   ensure that we close the menu after all the click events are   finished. However because this is too fast, the menu is already closed   and the anchor link is already unmounted and thus not clickable   anymore. So instead we use a double requestAnimationFrame (to mimick a   nextFrame as seen in the disposables from the React code). This   works, but a bit messy, oh well. The next reason why I am not that happy is because I can't reproduce   it in JSDOM (Jest tests). When you click a link in JSDOM it doesn't   update the window.location.hash or window.location.href. To mimick   that behaviour I put a @click event on the anchor to verify that we   actually clicked it. However this already works, even before the   ""fix"". So I left a TODO in there so that we can hopefully fix the   test, so that we can reproduce this behaviour.  Fixes: #14",ensure that anchor links are still clickable,"This is an issue in the Vue version (it just works in the React version) but I added tests for them anyway. While this solution ""works"" I am not 100% happy with it. Let me explain what's happening here and why I am not that happy about it: For starters, the Vue nextTick is apparently too fast. So what we do   is when we get the pointer up event, we will close the menu and   re-focus the button. We ran this code in a nextTick so that we can   ensure that we close the menu after all the click events are   finished. However because this is too fast, the menu is already closed   and the anchor link is already unmounted and thus not clickable   anymore. So instead we use a double requestAnimationFrame (to mimick a   nextFrame as seen in the disposables from the React code). This   works, but a bit messy, oh well. The next reason why I am not that happy is because I can't reproduce   it in JSDOM (Jest tests). When you click a link in JSDOM it doesn't   update the window.location.hash or window.location.href. To mimick   that behaviour I put a @click event on the anchor to verify that we   actually clicked it. However this already works, even before the   ""fix"". So I left a TODO in there so that we can hopefully fix the   test, so that we can reproduce this behaviour. Fixes: #14"
555,add prepublishOnly hooks,,add prepublishOnly hooks,
556,only passthrough the aria-disabled prop when true,Drop the disabled prop itself because doesn't make much sense,only passthrough the aria-disabled prop when true,Drop the disabled prop itself because doesn't make much sense
557,ensure that you can not click disabled items,,ensure that you can not click disabled items,
558,fix typo,,fix typo,
559,drop unneeded types in tsconfig.json,,drop unneeded types in tsconfig.json,
560,add extra tests to verify that @click works on MenuItem as='button',,add extra tests to verify that @click works on MenuItem as='button',
561,docs(React): jsx wrapped in enclosing tags (@headlessui-react/readme.md) (#10),,docs(React): jsx wrapped in enclosing tags (@headlessui-react/readme.md) (#10),
562,"docs(React): fix ""Transition"" link href in @headlessui-react readme (#9)",,"docs(React): fix ""Transition"" link href in @headlessui-react readme (#9)",
563,docs(React): improve documentation for Menu transitions (#7),  Improve documentation for Menu transitions   Update README.md ,docs(React): improve documentation for Menu transitions (#7),Improve documentation for Menu transitions Update README.md
564,docs: Add demo links,,docs: Add demo links,
565,version 0.1.1,,version 0.1.1,
566,make examples between Vue and React consistent,,make examples between Vue and React consistent,
567,use correct prettier settings,,use correct prettier settings,
568,build code snippets for the Vue playground,,build code snippets for the Vue playground,
569,add Menu examples in React,,add Menu examples in React,
570,use absolute path instead of relative,,use absolute path instead of relative,
571,add Menu examples in Vue,,add Menu examples in Vue,
572,fix vercel build for the Vue playground,,fix vercel build for the Vue playground,
573,configure vercel for routing,,configure vercel for routing,
574,add playground:build script,,add playground:build script,
575,prerender 404 pages with a table of contents of all examples,,prerender 404 pages with a table of contents of all examples,
576,cleanup scripts,use git command instead of some random realpath that is not installed everywhere,cleanup scripts,use git command instead of some random realpath that is not installed everywhere
577,fix vite package alias,,fix vite package alias,
578,generate all example paths at build time,,generate all example paths at build time,
579,make the vue playground buildable for Vercel,,make the vue playground buildable for Vercel,
580,bump dependencies,,bump dependencies,
581,Merge pull request #1 from tailwindlabs/document-react-components,"docs: Document React Menu, tweak Transition and Vue docs to be consistent",Merge pull request #1 from tailwindlabs/document-react-components,"docs: Document React Menu, tweak Transition and Vue docs to be consistent"
582,add vue as a peer dependency,,add vue as a peer dependency,
583,"remove test code, use mocks instead",,"remove test code, use mocks instead",
584,improve tsdx build,,improve tsdx build,
585,add some dead code elimination markers,,add some dead code elimination markers,
586,use headlessui identifier instead of tailwindui,,use headlessui identifier instead of tailwindui,
587,inline defaultState,"Otherwise we will be mutating the refs, and items from the first Menu on the page",inline defaultState,"Otherwise we will be mutating the refs, and items from the first Menu on the page"
588,use correct package reference,,use correct package reference,
589,make render logic consistent with the Vue implementation,,make render logic consistent with the Vue implementation,
590,"docs: Document React Menu, tweak Transition and Vue docs to be consistent",,"docs: Document React Menu, tweak Transition and Vue docs to be consistent",
591,docs: Add 'Dropdown' alias next to Menu Button in TOC,,docs: Add 'Dropdown' alias next to Menu Button in TOC,
592,setup @headlessui/react package,,setup @headlessui/react package,
593,setup @headlessui/vue package,,setup @headlessui/vue package,
594,setup monorepo,,setup monorepo,
595,init project,,init project,
